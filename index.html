<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
</head>
<canvas id="canvas" width="720" height="720" class="canvas"></canvas>
<div>
  <script>

    // window.addEventListener('DOMContentLoaded', (event) => {
    const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
    for (let t = 0; t < 10000000; t++) {
      squaretable[`${t}`] = Math.sqrt(t)
      if (t > 999) {
        t += 9
      }
    }
    let autobalance = 0
    let gotoflag = 0
    let worlddor = {}
    let toolpoint = {}
    let tooling = 0
    let tooltext = { lines: [] }
    let tnowime = Date.now()
    let datalong = 0
    function logBinarySize(string) {
      datalong += unescape(encodeURIComponent(string)).length

    }

    let localRoom = 0
    let localRooms = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    let lobbybuttons = []
    let champtimes = []
    let champids = []
    let video_recorder
    let recording = 0
    // function CanvasCaptureToWEBM(canvas, bitrate) {
    //   // the video_recorder is set to  '= new CanvasCaptureToWEBM(canvas, 4500000);' in the setup, 
    //   // it uses the same canvas as the rest of the file.
    //   // to start a recording call .record() on video_recorder
    //   /*
    //   for example, 
    //   if(keysPressed['-'] && recording == 0){
    //       recording = 1
    //       video_recorder.record()
    //   }
    //   if(keysPressed['='] && recording == 1){
    //       recording = 0
    //       video_recorder.stop()
    //       video_recorder.download('File Name As A String.webm')
    //   }
    //   */
    //   this.record = Record
    //   this.stop = Stop
    //   this.download = saveToDownloads
    //   let blobCaptures = []
    //   let outputFormat = {}
    //   let recorder = {}
    //   let canvasInput = canvas.captureStream()
    //   if (typeof canvasInput == undefined || !canvasInput) {
    //     return
    //   }
    //   const video = document.createElement('video')
    //   video.style.display = 'none'

    //   function Record() {
    //     let formats = [
    //       'video/vp8',
    //       "video/webm",
    //       'video/webm,codecs=vp9',
    //       "video/webm\;codecs=vp8",
    //       "video/webm\;codecs=daala",
    //       "video/webm\;codecs=h264",
    //       "video/mpeg"
    //     ];

    //     for (let t = 0; t < formats.length; t++) {
    //       if (MediaRecorder.isTypeSupported(formats[t])) {
    //         outputFormat = formats[t]
    //         break
    //       }
    //     }
    //     if (typeof outputFormat != "string") {
    //       return
    //     } else {
    //       let videoSettings = {
    //         mimeType: outputFormat,
    //         videoBitsPerSecond: bitrate || 2000000 // 2Mbps
    //       };
    //       blobCaptures = []
    //       try {
    //         recorder = new MediaRecorder(canvasInput, videoSettings)
    //       } catch (error) {
    //         return;
    //       }
    //       recorder.onstop = handleStop
    //       recorder.ondataavailable = handleAvailableData
    //       recorder.start(100)
    //     }
    //   }
    //   function handleAvailableData(event) {
    //     if (event.data && event.data.size > 0) {
    //       blobCaptures.push(event.data)
    //     }
    //   }
    //   function handleStop() {
    //     const superBuffer = new Blob(blobCaptures, { type: outputFormat })
    //     video.src = window.URL.createObjectURL(superBuffer)
    //   }
    //   function Stop() {
    //     recorder.stop()
    //     video.controls = true
    //   }
    //   function saveToDownloads(input) { // specifying a file name for the output
    //     const name = input || 'video_out.webm'
    //     const blob = new Blob(blobCaptures, { type: outputFormat })
    //     const url = window.URL.createObjectURL(blob)
    //     const storageElement = document.createElement('a')
    //     storageElement.style.display = 'none'
    //     storageElement.href = url
    //     storageElement.download = name
    //     document.body.appendChild(storageElement)
    //     storageElement.click()
    //     setTimeout(() => {
    //       document.body.removeChild(storageElement)
    //       window.URL.revokeObjectURL(url)
    //     }, 100)
    //   }
    // }
    const gamepadAPI = {
      controller: {},
      turbo: true,
      connect: function (evt) {
        if (navigator.getGamepads()[0] != null) {
          gamepadAPI.controller = navigator.getGamepads()[0]
          gamepadAPI.turbo = true;
        } else if (navigator.getGamepads()[1] != null) {
          gamepadAPI.controller = navigator.getGamepads()[0]
          gamepadAPI.turbo = true;
        } else if (navigator.getGamepads()[2] != null) {
          gamepadAPI.controller = navigator.getGamepads()[0]
          gamepadAPI.turbo = true;
        } else if (navigator.getGamepads()[3] != null) {
          gamepadAPI.controller = navigator.getGamepads()[0]
          gamepadAPI.turbo = true;
        }
        for (let i = 0; i < gamepads.length; i++) {
          if (gamepads[i] === null) {
            continue;
          }
          if (!gamepads[i].connected) {
            continue;
          }
        }
      },
      disconnect: function (evt) {
        gamepadAPI.turbo = false;
        delete gamepadAPI.controller;
      },
      update: function () {
        gamepadAPI.controller = navigator.getGamepads()[0]
        gamepadAPI.buttonsCache = [];// clear the buttons cache
        for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) {// move the buttons status from the previous frame to the cache
          gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
        }
        gamepadAPI.buttonsStatus = [];// clear the buttons status
        var c = gamepadAPI.controller || {}; // get the gamepad object
        var pressed = [];
        if (c.buttons) {
          for (var b = 0, t = c.buttons.length; b < t; b++) {// loop through buttons and push the pressed ones to the array
            if (c.buttons[b].pressed) {
              pressed.push(gamepadAPI.buttons[b]);
            }
          }
        }
        var axes = [];
        if (c.axes) {
          for (var a = 0, x = c.axes.length; a < x; a++) {// loop through axes and push their values to the array
            axes.push(c.axes[a].toFixed(2));
          }
        }
        gamepadAPI.axesStatus = axes;// assign received values
        gamepadAPI.buttonsStatus = pressed;
        // //////////////////////////////////////////////////////////console.log(pressed); // return buttons for debugging purposes
        return pressed;
      },
      buttonPressed: function (button, hold) {
        var newPress = false;
        for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) {// loop through pressed buttons
          if (gamepadAPI.buttonsStatus[i] == button) {// if we found the button we're looking for...
            newPress = true;// set the boolean variable to true
            if (!hold) {// if we want to check the single press
              for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) {// loop through the cached states from the previous frame
                if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                  newPress = false;
                }
              }
            }
          }
        }
        return newPress;
      },
      buttons: [
        'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
      ],
      buttonsCache: [],
      buttonsStatus: [],
      axesStatus: []
    };
    let canvas
    let canvas_context
    let keysPressed = {}
    let FLEX_engine
    let TIP_engine = {}
    let XS_engine
    let YS_engine
    class Point {
      constructor(x, y) {
        this.x = x
        this.y = y
        this.radius = 0
      }
      pointDistance(point) {
        return (new LineOP(this, point, "transparent", 0)).hypotenuse()
      }
    }

    class Vector { // vector math and physics if you prefer this over vector components on circles
      constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
        this.xmom = xmom
        this.ymom = ymom
        this.object = object
      }
      isToward(point) {
        let link = new LineOP(this.object, point)
        let dis1 = link.squareDistance()
        let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
        let link2 = new LineOP(dummy, point)
        let dis2 = link2.squareDistance()
        if (dis2 < dis1) {
          return true
        } else {
          return false
        }
      }
      rotate(angleGoal) {
        let link = new Line(this.xmom, this.ymom, 0, 0)
        let length = link.hypotenuse()
        let x = (length * Math.cos(angleGoal))
        let y = (length * Math.sin(angleGoal))
        this.xmom = x
        this.ymom = y
      }
      magnitude() {
        return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
      }
      normalize(size = 1) {
        let magnitude = this.magnitude()
        this.xmom /= magnitude
        this.ymom /= magnitude
        this.xmom *= size
        this.ymom *= size
      }
      multiply(vect) {
        let point = new Point(0, 0)
        let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
        return point.pointDistance(end)
      }
      add(vect) {
        return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
      }
      subtract(vect) {
        return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
      }
      divide(vect) {
        return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
      }
      draw() {
        let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
        let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
        link.draw()
      }
    }
    class Line {
      constructor(x, y, x2, y2, color, width) {
        this.x1 = x
        this.y1 = y
        this.x2 = x2
        this.y2 = y2
        this.color = color
        this.width = width
        this.local = 1
        this.id = Math.floor(Math.random() * 9000000)
      }
      angle() {
        return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
      }
      squareDistance() {
        let xdif = this.x1 - this.x2
        let ydif = this.y1 - this.y2
        let squareDistance = (xdif * xdif) + (ydif * ydif)
        return squareDistance
      }
      hypotenuse() {
        let xdif = this.x1 - this.x2
        let ydif = this.y1 - this.y2
        let hypotenuse = (xdif * xdif) + (ydif * ydif)
        if (hypotenuse < 10000000 - 1) {
          if (hypotenuse > 1000) {
            return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
          } else {
            return squaretable[`${Math.round(hypotenuse)}`]
          }
        } else {
          return Math.sqrt(hypotenuse)
        }
      }
      draw() {
        let linewidthstorage = canvas_context.lineWidth
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = this.width
        canvas_context.beginPath()
        canvas_context.moveTo(this.x1, this.y1)
        canvas_context.lineTo(this.x2, this.y2)
        canvas_context.stroke()
        canvas_context.lineWidth = linewidthstorage
      }
    }
    function findIntersections(circle, line) {
      const { x: h, y: k, radius: r } = circle;
      const { m, b } = line.getSlopeIntercept();
      const A = 1 + m * m;
      const B = 2 * (m * b - m * k - h);
      const C = h * h + k * k + b * b - 2 * b * k - r * r;
      const discriminant = B * B - 4 * A * C;
      if (discriminant < 0) {
        return [];
      }
      const x1 = (-B + Math.sqrt(discriminant)) / (2 * A);
      const x2 = (-B - Math.sqrt(discriminant)) / (2 * A);
      const y1 = m * x1 + b;
      const y2 = m * x2 + b;

      return [
        { x: x1, y: y1 },
        { x: x2, y: y2 }
      ];
    }
    function doesIntersect(circle, line) {
      const { x: h, y: k, radius: r } = circle;
      const { m, b } = line.getSlopeIntercept();

      // Debug logs to check values
      //////////////////////////////////////////////////////////console.log(`Circle: center=(${h}, ${k}), radius=${r}`);
      //////////////////////////////////////////////////////////console.log(`Line: slope=${m}, y-intercept=${b}`);

      // Coefficients of the quadratic equation ax^2 + bx + c = 0
      const A = 1 + m * m;
      const B = 2 * (m * b - m * k - h);
      const C = h * h + k * k + b * b - 2 * b * k - r * r;

      // Calculate the discriminant
      const discriminant = B * B - 4 * A * C;

      // Debug log for the discriminant
      //////////////////////////////////////////////////////////console.log(`Discriminant: ${discriminant}`);

      // If discriminant is negative, no real intersection
      return discriminant >= 0;
    }

    function inteceptCircleLineSeg(circle, line) {
      var a, b, c, d, u1, u2, ret, retobject, rettarget, v1, v2;
      v1 = {};
      v2 = {};
      v1.x = line.target.x - line.object.x;
      v1.y = line.target.y - line.object.y;
      v2.x = line.object.x - circle.x;
      v2.y = line.object.y - circle.y;
      b = (v1.x * v2.x + v1.y * v2.y);
      c = 2 * (v1.x * v1.x + v1.y * v1.y);
      b *= -2;
      d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));
      if (isNaN(d)) { // no intercept
        return [];
      }
      u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line
      u2 = (b + d) / c;
      retobject = {};   // return points
      rettarget = {}
      ret = []; // return array
      if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment
        retobject.x = line.object.x + v1.x * u1;
        retobject.y = line.object.y + v1.y * u1;
        ret[0] = retobject;
      }
      if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment
        rettarget.x = line.object.x + v1.x * u2;
        rettarget.y = line.object.y + v1.y * u2;
        ret[ret.length] = rettarget;
      }
      return ret;
    }




    class LineOP {
      constructor(object = { x: 0, y: 0 }, target = { x: 0, y: 0 }, color = "red", width = 1) {
        this.name = "LineOP"
        this.object = object
        this.target = target
        this.color = color
        this.width = width
        this.local = 1
        this.bodo = 1
        this.id = Math.floor(Math.random() * 9000000)
      }
      doesPerimeterTouch(circle) {
        return inteceptCircleLineSeg(circle, this).length > 0
      }
      crashPoint(circle) {
        return inteceptCircleLineSeg(circle, this)
      }
      getSlopeIntercept() {
        const m = (this.target.y - this.object.y) / (this.target.x - this.object.x);
        const b = this.object.y - m * this.object.x;
        return { m, b };
      }
      move() { }
      intersects(line) {
        //////////////////////////////////////////////////////////console.log(line)
        var det, gm, lm;
        det = (this.target.x - this.object.x) * (line.target.y - line.object.y) - (line.target.x - line.object.x) * (this.target.y - this.object.y);
        if (det === 0) {
          return false;
        } else {
          lm = ((line.target.y - line.object.y) * (line.target.x - this.object.x) + (line.object.x - line.target.x) * (line.target.y - this.object.y)) / det;
          gm = ((this.object.y - this.target.y) * (line.target.x - this.object.x) + (this.target.x - this.object.x) * (line.target.y - this.object.y)) / det;
          return (0 < lm && lm < 1) && (0 < gm && gm < 1);
        }
      }
      squareDistance() {
        let xdif = this.object.x - this.target.x
        let ydif = this.object.y - this.target.y
        let squareDistance = (xdif * xdif) + (ydif * ydif)
        return squareDistance
      }
      hypotenuse() {
        let xdif = this.object.x - this.target.x
        let ydif = this.object.y - this.target.y
        let hypotenuse = (xdif * xdif) + (ydif * ydif)
        if (hypotenuse < 10000000 - 1) {
          if (hypotenuse > 1000) {
            return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
          } else {
            return squaretable[`${Math.round(hypotenuse)}`]
          }
        } else {
          return Math.sqrt(hypotenuse)
        }
      }
      angle() {
        return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
      }
      draw() {
        let linewidthstorage = canvas_context.lineWidth
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = this.width
        canvas_context.beginPath()
        canvas_context.moveTo(this.object.x, this.object.y)
        canvas_context.lineTo(this.target.x, this.target.y)
        canvas_context.stroke()
        canvas_context.lineWidth = linewidthstorage
      }
    }
    class Rectangle {
      constructor(x, y, width, height, color) {
        this.x = x
        this.y = y
        this.height = height
        this.width = width
        this.color = color
        this.local = 1
        this.id = Math.floor(Math.random() * 9000000)
      }
      draw() {
        canvas_context.fillStyle = this.color
        canvas_context.fillRect(this.x, this.y, this.width, this.height)
      }
      move() {
        this.x += this.xmom
        this.y += this.ymom
      }
      isPointInside(point) {
        if (point.x >= this.x) {
          if (point.y >= this.y) {
            if (point.x <= this.x + this.width) {
              if (point.y <= this.y + this.height) {
                return true
              }
            }
          }
        }
        return false
      }
      doesPerimeterTouch(point) {
        if (point.x + point.radius >= this.x) {
          if (point.y + point.radius >= this.y) {
            if (point.x - point.radius <= this.x + this.width) {
              if (point.y - point.radius <= this.y + this.height) {
                return true
              }
            }
          }
        }
        return false
      }
    }
    class Circle {
      constructor(x = 0, y = 0, radius = 0, color = "red", xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
        this.name = "Circle"
        this.x = x
        this.y = y
        this.radius = radius
        this.color = color
        this.xmom = xmom
        this.ymom = ymom
        this.local = 1
        this.id = Math.floor(Math.random() * 9000000)
      }
      draw() {
        if (this.solar == 1 && this.guyid > -1) {

          this.guyIndex = champids.indexOf(this.guyid)
          if (players[this.guyIndex]) {
          } else {
            return
          }
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
        }
        canvas_context.lineWidth = this.strokeWidth
        canvas_context.strokeStyle = this.color
        canvas_context.beginPath();
        if (this.radius > 0) {
          canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
          canvas_context.fillStyle = this.color
          canvas_context.fill()
          canvas_context.stroke();
        } else {
          // //////////////////////////////////////////////////////////console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
        }
      }
      move() {
        if (this.reflect == 1) {
          if (this.x + this.radius > canvas.width) {
            if (this.xmom > 0) {
              this.xmom *= -1
            }
          }
          if (this.y + this.radius > canvas.height) {
            if (this.ymom > 0) {
              this.ymom *= -1
            }
          }
          if (this.x - this.radius < 0) {
            if (this.xmom < 0) {
              this.xmom *= -1
            }
          }
          if (this.y - this.radius < 0) {
            if (this.ymom < 0) {
              this.ymom *= -1
            }
          }
        }
        this.x += this.xmom
        this.y += this.ymom
      }
      unmove() {
        if (this.reflect == 1) {
          if (this.x + this.radius > canvas.width) {
            if (this.xmom > 0) {
              this.xmom *= -1
            }
          }
          if (this.y + this.radius > canvas.height) {
            if (this.ymom > 0) {
              this.ymom *= -1
            }
          }
          if (this.x - this.radius < 0) {
            if (this.xmom < 0) {
              this.xmom *= -1
            }
          }
          if (this.y - this.radius < 0) {
            if (this.ymom < 0) {
              this.ymom *= -1
            }
          }
        }
        this.x -= this.xmom
        this.y -= this.ymom
      }
      frictiveMove() {
        if (this.reflect == 1) {
          if (this.x + this.radius > canvas.width) {
            if (this.xmom > 0) {
              this.xmom *= -1
            }
          }
          if (this.y + this.radius > canvas.height) {
            if (this.ymom > 0) {
              this.ymom *= -1
            }
          }
          if (this.x - this.radius < 0) {
            if (this.xmom < 0) {
              this.xmom *= -1
            }
          }
          if (this.y - this.radius < 0) {
            if (this.ymom < 0) {
              this.ymom *= -1
            }
          }
        }
        this.x += this.xmom
        this.y += this.ymom
        this.xmom *= this.friction
        this.ymom *= this.friction
      }
      frictiveunMove() {
        if (this.reflect == 1) {
          if (this.x + this.radius > canvas.width) {
            if (this.xmom > 0) {
              this.xmom *= -1
            }
          }
          if (this.y + this.radius > canvas.height) {
            if (this.ymom > 0) {
              this.ymom *= -1
            }
          }
          if (this.x - this.radius < 0) {
            if (this.xmom < 0) {
              this.xmom *= -1
            }
          }
          if (this.y - this.radius < 0) {
            if (this.ymom < 0) {
              this.ymom *= -1
            }
          }
        }
        this.xmom /= this.friction
        this.ymom /= this.friction
        this.x -= this.xmom
        this.y -= this.ymom
      }
      isPointInside(point) {
        if (this.solar == 1 && this.guyid > -1) {

          this.guyIndex = champids.indexOf(this.guyid)
          if (players[this.guyIndex]) {
          } else {
            return
          }
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
        }
        let areaY = point.y - this.y
        let areaX = point.x - this.x
        if (((areaX * areaX) + (areaY * areaY)) <= (this.radius * this.radius)) {
          return true
        }
        return false
      }
      doesPerimeterTouch(point) {
        if (this.solar == 1 && this.guyid > -1) {

          this.guyIndex = champids.indexOf(this.guyid)
          if (players[this.guyIndex]) {
          } else {
            return
          }
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
        }
        let areaY = point.y - this.y
        let areaX = point.x - this.x
        if (((areaX * areaX) + (areaY * areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
          return true
        }
        return false
      }
    }


    let zoneA1 = new Circle(3120, 1340, 100, "blue")
    let zoneB2 = new Circle(2160, 2160, 100, "white")
    let zoneC3 = new Circle(888, 2664, 100, "red")

    let zone1 = new Circle(3650, 1800, 300, "orange")
    let zone2 = new Circle(2700, 2700, 300, "green")
    let zone3 = new Circle(1560, 3700, 300, "cyan")

    let zoneX1 = new Circle(4056, 2472, 100, "purple")
    let zoneY2 = new Circle(3100, 3250, 100, "pink")
    let zoneZ3 = new Circle(2160, 4130, 100, "gray")



    let zones = [zoneA1, zoneB2, zoneC3, zone1, zone2, zone3, zoneX1, zoneY2, zoneZ3]

    class Polygon {
      constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
        this.name = "Polygon"
        if (sides < 2) {
          sides = 2
        }
        this.reflect = reflect
        this.xmom = xmom
        this.ymom = ymom
        this.body = new Circle(x, y, size - (size * .293), "transparent")
        this.nodes = []
        this.angle = angle
        this.size = size
        this.color = color
        this.angleIncrement = (Math.PI * 2) / sides
        this.sides = sides
        for (let t = 0; t < sides; t++) {
          let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
          this.nodes.push(node)
          this.angle += this.angleIncrement
        }
      }
      isPointInside(point) { // rough approximation
        this.body.radius = this.size - (this.size * .293)
        if (this.sides <= 2) {
          return false
        }
        let areaY = point.y - this.body.y
        let areaX = point.x - this.body.x
        if (((areaX * areaX) + (areaY * areaY)) <= (this.body.radius * this.body.radius)) {
          return true
        }
        return false
      }
      move() {
        if (this.reflect == 1) {
          if (this.body.x > canvas.width) {
            if (this.xmom > 0) {
              this.xmom *= -1
            }
          }
          if (this.body.y > canvas.height) {
            if (this.ymom > 0) {
              this.ymom *= -1
            }
          }
          if (this.body.x < 0) {
            if (this.xmom < 0) {
              this.xmom *= -1
            }
          }
          if (this.body.y < 0) {
            if (this.ymom < 0) {
              this.ymom *= -1
            }
          }
        }
        this.body.x += this.xmom
        this.body.y += this.ymom
      }
      draw() {
        this.nodes = []
        this.angleIncrement = (Math.PI * 2) / this.sides
        this.body.radius = this.size - (this.size * .293)
        for (let t = 0; t < this.sides; t++) {
          let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
          this.nodes.push(node)
          this.angle += this.angleIncrement
        }
        canvas_context.strokeStyle = this.color
        canvas_context.fillStyle = this.color
        canvas_context.lineWidth = 0
        canvas_context.beginPath()
        canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
        for (let t = 1; t < this.nodes.length; t++) {
          canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
        }
        canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
        canvas_context.fill()
        canvas_context.stroke()
        canvas_context.closePath()
      }
    }
    class Shape {
      constructor(shapes) {
        this.shapes = shapes
      }
      draw() {
        for (let t = 0; t < this.shapes.length; t++) {
          this.shapes[t].draw()
        }
      }
      move() {
        if (typeof this.xmom != "number") {
          this.xmom = 0
        }
        if (typeof this.ymom != "number") {
          this.ymom = 0
        }
        for (let t = 0; t < this.shapes.length; t++) {
          this.shapes[t].x += this.xmom
          this.shapes[t].y += this.ymom
          this.shapes[t].draw()
        }
      }
      isPointInside(point) {
        for (let t = 0; t < this.shapes.length; t++) {
          if (this.shapes[t].isPointInside(point)) {
            return true
          }
        }
        return false
      }
      doesPerimeterTouch(point) {
        for (let t = 0; t < this.shapes.length; t++) {
          if (this.shapes[t].doesPerimeterTouch(point)) {
            return true
          }
        }
        return false
      }
      innerShape(point) {
        for (let t = 0; t < this.shapes.length; t++) {
          if (this.shapes[t].doesPerimeterTouch(point)) {
            return this.shapes[t]
          }
        }
        return false
      }
      isInsideOf(box) {
        for (let t = 0; t < this.shapes.length; t++) {
          if (box.isPointInside(this.shapes[t])) {
            return true
          }
        }
        return false
      }
      adjustByFromDisplacement(x, y) {
        for (let t = 0; t < this.shapes.length; t++) {
          if (typeof this.shapes[t].fromRatio == "number") {
            this.shapes[t].x += x * this.shapes[t].fromRatio
            this.shapes[t].y += y * this.shapes[t].fromRatio
          }
        }
      }
      adjustByToDisplacement(x, y) {
        for (let t = 0; t < this.shapes.length; t++) {
          if (typeof this.shapes[t].toRatio == "number") {
            this.shapes[t].x += x * this.shapes[t].toRatio
            this.shapes[t].y += y * this.shapes[t].toRatio
          }
        }
      }
      mixIn(arr) {
        for (let t = 0; t < arr.length; t++) {
          for (let k = 0; k < arr[t].shapes.length; k++) {
            this.shapes.push(arr[t].shapes[k])
          }
        }
      }
      push(object) {
        this.shapes.push(object)
      }
    }

    class Spring {
      constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
        if (body == 0) {
          this.body = new Circle(x, y, radius, color)
          this.anchor = new Circle(x, y, radius, color)
          this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
          this.length = length
        } else {
          this.body = body
          this.anchor = new Circle(x, y, radius, color)
          this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
          this.length = length
        }
        this.gravity = gravity
        this.width = width
      }
      balance() {
        this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
        if (this.beam.hypotenuse() < this.length) {
          this.body.xmom += (this.body.x - this.anchor.x) / this.length
          this.body.ymom += (this.body.y - this.anchor.y) / this.length
          this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
          this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
        } else {
          this.body.xmom -= (this.body.x - this.anchor.x) / this.length
          this.body.ymom -= (this.body.y - this.anchor.y) / this.length
          this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
          this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
        }
        let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
        let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
        this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
        this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
        this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
        this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
      }
      draw() {
        this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
        this.beam.draw()
        this.body.draw()
        this.anchor.draw()
      }
      move() {
        this.anchor.ymom += this.gravity
        this.anchor.move()
      }

    }
    class SpringOP {
      constructor(body, anchor, length, width = 3, color = body.color) {
        this.body = body
        this.anchor = anchor
        this.beam = new LineOP(body, anchor, color, width)
        this.length = length
      }
      balance() {
        if (this.beam.hypotenuse() < this.length) {
          this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
          this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
          this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
          this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
        } else if (this.beam.hypotenuse() > this.length) {
          this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
          this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
          this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
          this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
        }

        let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
        let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
        this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
        this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
        this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
        this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
      }
      draw() {
        this.beam.draw()
      }
      move() {
        //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
      }
    }

    class Color {
      constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
        this.hue = baseColor
        if (red != -1 && green != -1 && blue != -1) {
          this.r = red
          this.g = green
          this.b = blue
          if (alpha != 1) {
            if (alpha < 1) {
              this.alpha = alpha
            } else {
              this.alpha = alpha / 255
              if (this.alpha > 1) {
                this.alpha = 1
              }
            }
          }
          if (this.r > 255) {
            this.r = 255
          }
          if (this.g > 255) {
            this.g = 255
          }
          if (this.b > 255) {
            this.b = 255
          }
          if (this.r < 0) {
            this.r = 0
          }
          if (this.g < 0) {
            this.g = 0
          }
          if (this.b < 0) {
            this.b = 0
          }
        } else {
          this.r = 0
          this.g = 0
          this.b = 0
        }
      }
      normalize() {
        if (this.r > 255) {
          this.r = 255
        }
        if (this.g > 255) {
          this.g = 255
        }
        if (this.b > 255) {
          this.b = 255
        }
        if (this.r < 0) {
          this.r = 0
        }
        if (this.g < 0) {
          this.g = 0
        }
        if (this.b < 0) {
          this.b = 0
        }
      }
      randomLight() {
        var letters = '0123456789ABCDEF';
        var hash = '#';
        for (var i = 0; i < 6; i++) {
          hash += letters[(Math.floor(Math.random() * 12) + 4)];
        }
        var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
        return color;
      }
      randomDark() {
        var letters = '0123456789ABCDEF';
        var hash = '#';
        for (var i = 0; i < 6; i++) {
          hash += letters[(Math.floor(Math.random() * 12))];
        }
        var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
        return color;
      }
      random() {
        var letters = '0123456789ABCDEF';
        var hash = '#';
        for (var i = 0; i < 6; i++) {
          hash += letters[(Math.floor(Math.random() * 16))];
        }
        var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
        return color;
      }
    }
    class Softbody { //buggy, spins in place
      constructor(x, y, radius, color, members = 10, memberLength = 5, force = 10, gravity = 0) {
        this.springs = []
        this.pin = new Circle(x, y, radius, color)
        this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
        this.springs.push(this.spring)
        for (let k = 0; k < members; k++) {
          this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
          if (k < members - 1) {
            this.springs.push(this.spring)
          } else {
            this.spring.anchor = this.pin
            this.springs.push(this.spring)
          }
        }
        this.forceConstant = force
        this.centroid = new Point(0, 0)
      }
      circularize() {
        this.xpoint = 0
        this.ypoint = 0
        for (let s = 0; s < this.springs.length; s++) {
          this.xpoint += (this.springs[s].anchor.x / this.springs.length)
          this.ypoint += (this.springs[s].anchor.y / this.springs.length)
        }
        this.centroid.x = this.xpoint
        this.centroid.y = this.ypoint
        this.angle = 0
        this.angleIncrement = (Math.PI * 2) / this.springs.length
        for (let t = 0; t < this.springs.length; t++) {
          this.springs[t].body.x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
          this.springs[t].body.y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
          this.angle += this.angleIncrement
        }
      }
      balance() {
        for (let s = this.springs.length - 1; s >= 0; s--) {
          this.springs[s].balance()
        }
        this.xpoint = 0
        this.ypoint = 0
        for (let s = 0; s < this.springs.length; s++) {
          this.xpoint += (this.springs[s].anchor.x / this.springs.length)
          this.ypoint += (this.springs[s].anchor.y / this.springs.length)
        }
        this.centroid.x = this.xpoint
        this.centroid.y = this.ypoint
        for (let s = 0; s < this.springs.length; s++) {
          this.link = new Line(this.centroid.x, this.centroid.y, this.springs[s].anchor.x, this.springs[s].anchor.y, 0, "transparent")
          if (this.link.hypotenuse() != 0) {
            this.springs[s].anchor.xmom += (((this.springs[s].anchor.x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
            this.springs[s].anchor.ymom += (((this.springs[s].anchor.y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
          }
        }
        for (let s = 0; s < this.springs.length; s++) {
          this.springs[s].move()
        }
        for (let s = 0; s < this.springs.length; s++) {
          this.springs[s].draw()
        }
      }
    }
    class Observer {
      constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
        this.body = new Circle(x, y, radius, color)
        this.color = color
        this.ray = []
        this.rayrange = range
        this.globalangle = Math.PI
        this.gapangle = angle
        this.currentangle = 0
        this.obstacles = []
        this.raymake = rays
      }
      beam() {
        this.currentangle = this.gapangle / 2
        for (let k = 0; k < this.raymake; k++) {
          this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
          let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
          ray.collided = 0
          ray.lifespan = this.rayrange - 1
          this.ray.push(ray)
        }
        for (let f = 0; f < this.rayrange; f++) {
          for (let t = 0; t < this.ray.length; t++) {
            if (this.ray[t].collided < 1) {
              this.ray[t].move()
              for (let q = 0; q < this.obstacles.length; q++) {
                if (this.obstacles[q].isPointInside(this.ray[t])) {
                  this.ray[t].collided = 1
                }
              }
            }
          }
        }
      }
      draw() {
        this.beam()
        this.body.draw()
        canvas_context.lineWidth = 1
        canvas_context.fillStyle = this.color
        canvas_context.strokeStyle = this.color
        canvas_context.beginPath()
        canvas_context.moveTo(this.body.x, this.body.y)
        for (let y = 0; y < this.ray.length; y++) {
          canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
          canvas_context.lineTo(this.body.x, this.body.y)
        }
        canvas_context.stroke()
        canvas_context.fill()
        this.ray = []
      }
    }
    function setUp(canvas_pass, style = "#000000") {
      canvas = canvas_pass
      // video_recorder = new CanvasCaptureToWEBM(canvas, 4500000);
      canvas_context = canvas.getContext('2d');
      canvas.style.background = style
      window.setInterval(function () {
        main()

      }, 17)
      document.addEventListener('keydown', (event) => {
        keysPressed[event.key] = true;
      });
      document.addEventListener('keyup', (event) => {
        delete keysPressed[event.key];
      });
      window.addEventListener('pointerdown', e => {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine 
        TIP_engine.y = YS_engine 
        TIP_engine.body = TIP_engine
        if(trilas.time > 7200){
          trilas = new Trilas(360,360)
        }

      });



      window.addEventListener('contextmenu', e => {
        e.preventDefault()
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine 
        TIP_engine.y = YS_engine 
        TIP_engine.body = TIP_engine
      });



      window.addEventListener('pointermove', continued_stimuli);
      window.addEventListener('pointerup', e => {
        // window.removeEventListener("pointermove", continued_stimuli);
      })
      function continued_stimuli(e) {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine - translator.x
        TIP_engine.y = YS_engine - translator.y
        TIP_engine.body = TIP_engine
    }
  }
    function control(object, speed = 1) { // basic control for objects
      if (typeof object.body != 'undefined') {
        if (keysPressed['w']) {
          object.body.y -= speed
        }
        if (keysPressed['d']) {
          object.body.x += speed
        }
        if (keysPressed['s']) {
          object.body.y += speed
        }
        if (keysPressed['a']) {
          object.body.x -= speed
        }
      } else if (typeof object != 'undefined') {
        if (keysPressed['w']) {
          object.y -= speed
        }
        if (keysPressed['d']) {
          object.x += speed
        }
        if (keysPressed['s']) {
          object.y += speed
        }
        if (keysPressed['a']) {
          object.x -= speed
        }
      }
    }
    function getRandomLightColor() { // random color that will be visible on  black background
      var letters = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += letters[(Math.floor(Math.random() * 12) + 4)];
      }
      return color;
    }
    function getRandomColor() { // random color
      var letters = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += letters[(Math.floor(Math.random() * 16) + 0)];
      }
      return color;
    }
    function getRandomDarkColor() {// color that will be visible on a black background
      var letters = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += letters[(Math.floor(Math.random() * 12))];
      }
      return color;
    }
    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
      let limit = granularity
      let shape_array = []
      for (let t = 0; t < limit; t++) {
        let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
        circ.toRatio = t / limit
        circ.fromRatio = (limit - t) / limit
        shape_array.push(circ)
      }
      return (new Shape(shape_array))
    }

    function castBetweenPoints(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
      let limit = granularity
      let shape_array = []
      for (let t = 0; t < limit; t++) {
        let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
        circ.toRatio = t / limit
        circ.fromRatio = (limit - t) / limit
        shape_array.push(circ)
      }
      return shape_array
    }

    class Disang {
      constructor(dis, ang) {
        this.dis = dis
        this.angle = ang
      }
    }

    class BezierHitbox {
      constructor(x, y, cx, cy, ex, ey, color = "red") { // this function takes a starting x,y, a control point x,y, and a end point x,y
        this.color = color
        this.x = x
        this.y = y
        this.cx = cx
        this.cy = cy
        this.ex = ex
        this.ey = ey
        this.metapoint = new Circle((x + cx + ex) / 3, (y + cy + ey) / 3, 3, "#FFFFFF")
        this.granularity = 100
        this.body = [...castBetweenPoints((new Point(this.x, this.y)), (new Point(this.ex, this.ey)), this.granularity, 0)]

        let angle = (new Line(this.x, this.y, this.ex, this.ey)).angle()

        this.angles = []
        for (let t = 0; t < this.granularity; t++) {
          this.angles.push(angle)
        }
        for (let t = 0; t <= 1; t += 1 / this.granularity) {
          this.body.push(this.getQuadraticXY(t))
          this.angles.push(this.getQuadraticAngle(t))
        }
        this.hitbox = []
        for (let t = 0; t < this.body.length; t++) {
          let link = new LineOP(this.body[t], this.metapoint)
          let disang = new Disang(link.hypotenuse(), link.angle() + (Math.PI * 2))
          this.hitbox.push(disang)
        }
        this.constructed = 1
      }
      isPointInside(point) {
        let link = new LineOP(point, this.metapoint)
        let angle = (link.angle() + (Math.PI * 2))
        let dis = link.hypotenuse()
        for (let t = 1; t < this.hitbox.length; t++) {
          if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
            continue
          }
          if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
            if (dis < (this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) {
              return true
            }
          }
        }
        return false
      }
      doesPerimeterTouch(point) {
        let link = new LineOP(point, this.metapoint)
        let angle = (link.angle() + (Math.PI * 2))
        let dis = link.hypotenuse()
        for (let t = 1; t < this.hitbox.length; t++) {
          if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
            continue
          }
          if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
            if (dis < ((this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) + point.radius) {
              return this.angles[t]
            }
          }
        }
        return false
      }
      draw() {
        this.metapoint.draw()
        let tline = new Line(this.x, this.y, this.ex, this.ey, this.color, 3)
        tline.draw()
        canvas_context.beginPath()
        this.median = new Point((this.x + this.ex) * .5, (this.y + this.ey) * .5)
        let angle = (new LineOP(this.median, this.metapoint)).angle()
        let dis = (new LineOP(this.median, this.metapoint)).hypotenuse()
        canvas_context.bezierCurveTo(this.x, this.y, this.cx - (Math.cos(angle) * dis * .38), this.cy - (Math.sin(angle) * dis * .38), this.ex, this.ey)

        canvas_context.fillStyle = this.color
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = 3
        canvas_context.stroke()
      }
      getQuadraticXY(t) {
        return new Point((((1 - t) * (1 - t)) * this.x) + (2 * (1 - t) * t * this.cx) + (t * t * this.ex), (((1 - t) * (1 - t)) * this.y) + (2 * (1 - t) * t * this.cy) + (t * t * this.ey))
      }
      getQuadraticAngle(t) {
        var dx = 2 * (1 - t) * (this.cx - this.x) + 2 * t * (this.ex - this.cx);
        var dy = 2 * (1 - t) * (this.cy - this.y) + 2 * t * (this.ey - this.cy);
        return -Math.atan2(dx, dy) + 0.5 * Math.PI;
      }
    }
    Number.prototype.between = function (a, b, inclusive) {
      var min = Math.min(a, b),
        max = Math.max(a, b);
      return inclusive ? this >= min && this <= max : this > min && this < max;
    }



    class Weight {
      constructor(from, to) {
        this.value = this.weight()
        this.from = from
        this.to = to
        this.change = 0
        this.delta = 1
      }
      valueOf() {
        return this.value
      }
      weight() {
        return ((Math.random() - .5) * 2)
      }
      setChange(num) {
        this.change = num
      }
      setWeight(num) {
        this.value = num
      }
    }
    class Perceptron {
      constructor(inputs) {
        this.bias = ((Math.random() - .5) * 2) / 1
        this.value = this.bias
        this.weights = []
        this.outputConnections = []
        this.inputs = inputs
        this.error = 0
        this.delta = 1
        for (let t = 0; t < this.inputs.length; t++) {
          this.weights.push(this.weight(this.inputs[t]))
        }
        this.z = -1
        this.change = 0
      }
      setError(error) {
        this.error = error
      }
      setDelta(delta) {
        this.delta = delta
        for (let t = 0; t < this.outputConnections.length; t++) {
          this.outputConnections[t].delta = this.delta
        }
      }
      setBias(bias) {
        this.bias = bias
      }
      setChange(num) {
        this.change = num
      }
      weight(link) {
        let weight = new Weight(link, this)
        if (typeof link != "number") {
          link.outputConnections.push(weight)
        }
        return weight
      }
      valueOf() {
        return this.value
      }
      compute(inputs = this.inputs) {
        this.inputs = inputs
        this.value = this.bias
        for (let t = 0; t < inputs.length; t++) {
          if (t > this.weights.length - 1) {
            this.weights.push(this.weight())
            this.value += (inputs[t].valueOf() * this.weights[t].valueOf())
          } else {
            this.value += (inputs[t].valueOf() * this.weights[t].valueOf())
          }
        }
        this.sig()
        // this.gauss()
        return this.value
      }
      relu() {
        this.value = Math.min(Math.max(this.value, perc.reluslime), 1)
      }
      sig() {
        this.value = 1 / (1 + (Math.pow(Math.E, -this.value)))
      }
      gauss() {
        this.value = Math.min(Math.max(Math.abs(this.value), 0.00000001), 1)

      }
    }
    class Network {
      constructor(inputs, layerSetupArray) {
        this.reluslime = .00001
        this.momentum = .025
        this.learningRate = .0025
        this.setup = layerSetupArray
        this.inputs = inputs
        this.structure = []
        this.outputs = []
        for (let t = 0; t < layerSetupArray.length; t++) {
          let scaffold = []
          for (let k = 0; k < layerSetupArray[t]; k++) {
            let cept
            if (t == 0) {
              cept = new Perceptron(this.inputs)
            } else {
              cept = new Perceptron(this.structure[t - 1])
            }
            scaffold.push(cept)
          }
          this.structure.push(scaffold)
        }
        this.lastinputs = [...this.inputs]
        this.lastgoals = [...this.lastinputs]
        this.swap = []
      }

      becomeNetworkFrom(network) { //using a js file with one variable can be good for this
        // //////////////////////////////////////////////////////////console.log(this.structure[0][0].bias)
        for (let t = 0; t < this.structure.length; t++) {
          // //////////////////////////////////////////////////////////console.log("h1")
          for (let k = 0; k < this.structure[t].length; k++) {
            // //////////////////////////////////////////////////////////console.log("h2")
            this.structure[t][k].bias = network.structure[t][k].bias
            for (let w = 0; w < this.structure[t][k].weights.length; w++) {
              // //////////////////////////////////////////////////////////console.log("h3")
              this.structure[t][k].weights[w].setWeight(network.structure[t][k][w].valueOf())
            }
          }
        }
        // //////////////////////////////////////////////////////////console.log(this.structure[0][0].bias)
      }
      log() {
        let json = {}
        json.structure = []
        json.setup = [...this.setup]
        for (let t = 0; t < this.structure.length; t++) {
          json.structure.push({})
          for (let k = 0; k < this.structure[t].length; k++) {
            json.structure[t][k] = {}
            json.structure[t][k].bias = this.structure[t][k].bias.valueOf()
            for (let w = 0; w < this.structure[t][k].weights.length; w++) {
              json.structure[t][k][w] = (this.structure[t][k].weights[w].valueOf())
            }
          }
        }
        //////////////////////////////////////////////////////////console.log(json)
      }
      calculateDeltasSigmoid(goals) {
        for (let t = this.structure.length - 1; t >= 0; t--) {
          const layer = this.structure[t]
          for (let k = 0; k < layer.length; k++) {
            const perceptron = layer[k]
            let output = perceptron.valueOf()
            let error = 0
            if (t === this.structure.length - 1) {
              error = goals[k] - output;
            } else {
              for (let k = 0; k < perceptron.outputConnections.length; k++) {
                const currentConnection = perceptron.outputConnections[k]
                ////////////////////////////////////////////////////////////console.log(currentConnection)
                error += currentConnection.to.delta * currentConnection.valueOf()
              }
            }
            perceptron.setError(error)
            perceptron.setDelta(error * output * (1 - output))
          }
        }
      }
      adjustWeights() {
        for (let t = 0; t < this.structure.length; t++) {
          const layer = this.structure[t]
          for (let k = 0; k < layer.length; k++) {
            const perceptron = layer[k]
            let delta = perceptron.delta
            for (let i = 0; i < perceptron.weights.length; i++) {
              const connection = perceptron.weights[i]
              let change = connection.change
              change = (this.learningRate * delta * perceptron.inputs[i].valueOf()) + (this.momentum * change);
              connection.setChange(change)
              connection.setWeight(connection.valueOf() + change)
            }
            perceptron.setBias(perceptron.bias + (this.learningRate * delta))
          }
        }
      }
      clone(nw) {
        let input = nw.inputs
        let perc = new Network(input, nw.setup)
        for (let t = 0; t < nw.structure.length; t++) {
          for (let k = 0; k < nw.structure[t].length; k++) {
            perc.structure[t][k] = new Perceptron([0, 0, 0, 0, 0, 0, 0])
            for (let f = 0; f < nw.structure[t][k].weights.length; f++) {
              perc.structure[t][k].weights[f] = nw.structure[t][k].weights[f]
              perc.structure[t][k].bias = nw.structure[t][k].bias
            }
          }
        }
        return perc
      }
      compute(inputs = this.inputs) {
        this.inputs = [...inputs]
        for (let t = 0; t < this.structure.length; t++) {
          for (let k = 0; k < this.structure[t].length; k++) {
            if (t == 0) {
              this.structure[t][k].compute(this.inputs)
            } else {
              this.structure[t][k].compute(this.structure[t - 1])
            }
          }
        }
        this.outputs = []
        this.dataoutputs = []
        for (let t = 0; t < this.structure[this.structure.length - 1].length; t++) {
          this.outputs.push(this.structure[this.structure.length - 1][t].valueOf())
          this.dataoutputs.push(new Data(this.structure[this.structure.length - 1][t].valueOf()))
        }
      }
    }
    class Data {
      constructor(input = -100) {
        this.delta = 0
        this.outputConnections = []
        if (input == -100) {
          this.value = this.weight()
        } else {
          this.value = input
        }
      }
      valueOf() {
        return this.value
      }
      weight() {
        return Math.random() - .5
      }
    }

    let setup_canvas = document.getElementById('canvas') //getting canvas from document

    setUp(setup_canvas) // setting up canvas refrences, starting timer. 

    // object instantiation and creation happens here 

    class WallSpike {
      constructor(track = { x: 0, y: 0 }, length = 1, angle = 1, color = "red") {
        this.name = "WallSpike"
        this.track = track
        this.x = this.track.x
        this.y = this.track.y
        this.angle = angle + .0925
        this.color = color
        this.radius = length
      }

      move() { }
      draw() {
        this.life = 9999999
        this.x = this.track.x
        this.y = this.track.y
        // let p = new Circle(this.x - (Math.cos(this.angle - 1) * 8), this.y - (Math.sin(this.angle - 1) * 8), 3, "red")
        // let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
        // let k = new Circle(this.x - (Math.cos(this.angle - .75) * this.radius), this.y - (Math.sin(this.angle - .75) * this.radius), 3, "white")
        // // p.draw()
        // // m.draw()

        // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        // p2.draw()
        // m2.draw()

        let p = new Circle(this.x - (Math.cos(this.angle - 1) * -5), this.y - (Math.sin(this.angle - 1) * -5), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * -5), this.y - (Math.sin(this.angle - .75) * -5), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle - .875) * this.radius), this.y - (Math.sin(this.angle - .875) * this.radius), 3, "white")

        let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * -5), this.y - (Math.sin(this.angle + 1) * -5), 3, "blue")
        let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * -5), this.y - (Math.sin(this.angle + .5) * -5), 3, "blue")
        let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")


        let l1 = new LineOP(p, k, this.color, 6)
        l1.draw()
        let l2 = new LineOP(m, k, this.color, 6)
        l2.draw()

        let f1 = new LineOP(p2, k2, this.color, 6)
        f1.draw()
        let f2 = new LineOP(m2, k2, this.color, 6)
        f2.draw()

        k2.draw()

        k.draw()

      }
      doesPerimeterTouch(circle) {
        this.life = 9999999
        this.x = this.track.x
        this.y = this.track.y
        let p = new Circle(this.x - (Math.cos(this.angle - 1) * -5), this.y - (Math.sin(this.angle - 1) * -5), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * -5), this.y - (Math.sin(this.angle - .75) * -5), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle - .875) * this.radius), this.y - (Math.sin(this.angle - .875) * this.radius), 3, "white")

        let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * -5), this.y - (Math.sin(this.angle + 1) * -5), 3, "blue")
        let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * -5), this.y - (Math.sin(this.angle + .5) * -5), 3, "blue")
        let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        let l1 = new LineOP(p, k, "gray", 6)
        // l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        // l2.draw()
        let f1 = new LineOP(p2, k2, "gray", 6)
        // f1.draw()
        let f2 = new LineOP(m2, k2, "gray", 6)
        // f2.draw()
        // k2.draw()
        // k.draw()
        // //////////////////////////////////////////////////////////console.log(circle)
        let wet = 0
        if (l1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (f1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (f2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        let trapper = 0
        if (circle == players[0].body) {
          trapper = 1
        }
        if (wet == 1) {
          for (let z = 0; z < 8; z++) {

            if (trapper == 0) {

              let pc1 = l1.crashPoint(circle)
              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                circle.x -= Math.cos(l.angle()) * 3
                circle.y -= Math.sin(l.angle()) * 3
              }
              let pc2 = l2.crashPoint(circle)
              if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                circle.x -= Math.cos(l.angle()) * 3
                circle.y -= Math.sin(l.angle()) * 3
              }
              let pc3 = f1.crashPoint(circle)
              if (pc3.length > 0) {
                let l = new LineOP(pc3[0], circle)
                circle.x -= Math.cos(l.angle()) * 3
                circle.y -= Math.sin(l.angle()) * 3
              }
              let pc4 = f2.crashPoint(circle)
              if (pc4.length > 0) {
                let l = new LineOP(pc4[0], circle)
                circle.x -= Math.cos(l.angle()) * 3
                circle.y -= Math.sin(l.angle()) * 3
              }
            } else {
              let pc1 = l1.crashPoint(circle)
              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                let a = l.angle()
                //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                circle.x -= Math.cos(a) * 3
                circle.y -= Math.sin(a) * 3
                //translator.x += Math.cos(a) * 3
                //translator.y += Math.sin(a) * 3
              }
              let pc2 = l2.crashPoint(circle)
              if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                let a = l.angle()
                //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                circle.x -= Math.cos(a) * 3
                circle.y -= Math.sin(a) * 3
                //translator.x += Math.cos(a) * 3
                //translator.y += Math.sin(a) * 3
              }
              let pc3 = f1.crashPoint(circle)
              if (pc3.length > 0) {
                let l = new LineOP(pc3[0], circle)
                let a = l.angle()
                //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                circle.x -= Math.cos(a) * 3
                circle.y -= Math.sin(a) * 3
                //translator.x += Math.cos(a) * 3
                //translator.y += Math.sin(a) * 3
              }
              let pc4 = f2.crashPoint(circle)
              if (pc4.length > 0) {
                let l = new LineOP(pc4[0], circle)
                let a = l.angle()
                //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                circle.x -= Math.cos(a) * 3
                circle.y -= Math.sin(a) * 3
                //translator.x += Math.cos(a) * 3
                //translator.y += Math.sin(a) * 3
              }

            }
          }



          return true
        }
        return false
      }
    }



    class YSpike {
      constructor(guyIndex = 0, angle = 0, color = "red") {
        this.name = "YSpike"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.angle = angle
        this.color = color
        this.radius = 30
        this.local = 1
        this.solar = 1
        this.song = "slughorns.wav"
        this.id = Math.floor(Math.random() * 9000000)
      }

      move() { }
      draw() {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let p = new Circle(this.x - (Math.cos(this.angle - 1) * 8), this.y - (Math.sin(this.angle - 1) * 8), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle - .75) * this.radius), this.y - (Math.sin(this.angle - .75) * this.radius), 3, "white")
        // p.draw()
        // m.draw()

        let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        // p2.draw()
        // m2.draw()

        let l1 = new LineOP(p, k, "gray", 6)
        l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        l2.draw()

        let f1 = new LineOP(p2, k2, "gray", 6)
        f1.draw()
        let f2 = new LineOP(m2, k2, "gray", 6)
        f2.draw()

        k2.draw()

        k.draw()

      }
      doesPerimeterTouch(circle) {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y

        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }
        let p = new Circle(this.x - (Math.cos(this.angle - 1) * 8), this.y - (Math.sin(this.angle - 1) * 8), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .75) * 8), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle - .875) * this.radius), this.y - (Math.sin(this.angle - .875) * this.radius), 3, "white")

        let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        let l1 = new LineOP(p, k, "gray", 6)
        // l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        // l2.draw()
        let f1 = new LineOP(p2, k2, "gray", 6)
        // f1.draw()
        let f2 = new LineOP(m2, k2, "gray", 6)
        // f2.draw()
        // k2.draw()
        // k.draw()
        //////////////////////////////////////////////////////////console.log(circle)
        let wet = 0
        if (l1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (f1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (f2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        let trapper = 0
        if (circle == players[0].body) {
          trapper = 1
        }
        if (wet == 1) {
          for (let z = 0; z < 10; z++) {
            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
            let pc1 = l1.crashPoint(circle)
            let pc2 = l2.crashPoint(circle)
            let pc3 = f1.crashPoint(circle)
            let pc4 = f2.crashPoint(circle)
            if (trapper == 0) {

              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc3.length > 0) {
                let l = new LineOP(pc3[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc4.length > 0) {
                let l = new LineOP(pc4[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              }
            } else {
              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc3.length > 0) {
                let l = new LineOP(pc3[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc4.length > 0) {
                let l = new LineOP(pc4[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              }

            }

            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
          }



          return true
        }
        return false
      }
    }




    class NhaiSpike {
      constructor(guyIndex = 0, angle = 0, color = "red") {
        this.name = "NhaiSpike"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.angle = angle
        this.color = color
        this.solar = 1
        this.radius = 30
        this.local = 1
        this.song = "slughorns.wav"
        this.moveAngle = 1
        this.id = Math.floor(Math.random() * 9000000)
      }

      move() { }
      draw() {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let p = new Circle(this.x - (Math.cos(this.angle - 1) * 8), this.y - (Math.sin(this.angle - 1) * 8), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle - .75) * this.radius), this.y - (Math.sin(this.angle - .75) * this.radius), 3, "purple")
        // p.draw()
        // m.draw()

        let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "purple")
        // p2.draw()
        // m2.draw()

        let l1 = new LineOP(p, k, "yellow", 6)
        l1.draw()
        let l2 = new LineOP(m, k, "yellow", 6)
        l2.draw()

        let f1 = new LineOP(p2, k2, "yellow", 6)
        f1.draw()
        let f2 = new LineOP(m2, k2, "yellow", 6)
        f2.draw()

        k2.draw()

        k.draw()

      }
      doesPerimeterTouch(circle) {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y

        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }
        let p = new Circle(this.x - (Math.cos(this.angle - 1) * 8), this.y - (Math.sin(this.angle - 1) * 8), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .75) * 8), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle - .875) * this.radius), this.y - (Math.sin(this.angle - .875) * this.radius), 3, "white")

        let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        let l1 = new LineOP(p, k, "gray", 6)
        // l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        // l2.draw()
        let f1 = new LineOP(p2, k2, "gray", 6)
        // f1.draw()
        let f2 = new LineOP(m2, k2, "gray", 6)
        // f2.draw()
        // k2.draw()
        // k.draw()
        //////////////////////////////////////////////////////////console.log(circle)
        let wet = 0
        if (l1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (f1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (f2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        let trapper = 0
        if (circle == players[0].body) {
          trapper = 1
        }
        if (wet == 1) {
          for (let z = 0; z < 10; z++) {
            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
            let pc1 = l1.crashPoint(circle)
            let pc2 = l2.crashPoint(circle)
            let pc3 = f1.crashPoint(circle)
            let pc4 = f2.crashPoint(circle)
            if (trapper == 0) {

              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc3.length > 0) {
                let l = new LineOP(pc3[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc4.length > 0) {
                let l = new LineOP(pc4[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              }
            } else {
              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc3.length > 0) {
                let l = new LineOP(pc3[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc4.length > 0) {
                let l = new LineOP(pc4[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              }

            }

            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
          }



          return true
        }
        return false
      }
    }


    class Bananas {
      constructor(guyIndex = 0, angle = 0, color = "red") {
        this.name = "Bananas"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.angle = angle
        this.color = color
        this.solar = 1
        this.radius = 64
        this.local = 1
        // this.moveAngle = 1
        this.id = Math.floor(Math.random() * 9000000)
      }

      move() { }
      draw() {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y

        this.angle += 1 * (Math.PI / 24)
        let pile = []
        for (let t = 0; t < 3; t++) {
          let x = this.x + (Math.cos(this.angle) * this.radius)
          let y = this.y + (Math.sin(this.angle) * this.radius)
          let d1 = new Circle(x, y, 16, "yellow")
          d1.draw()
          this.angle += (Math.PI * 2) / 3
        }

      }
      doesPerimeterTouch(circle) {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y

        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }

        // this.angle += 1* (Math.PI / 24)
        let pile = []
        let wet = 0
        for (let t = 0; t < 3; t++) {
          let x = this.x + (Math.cos(this.angle) * this.radius)
          let y = this.y + (Math.sin(this.angle) * this.radius)
          let d1 = new Circle(x, y, 16, "yellow")
          this.angle += (Math.PI * 2) / 3
          if (d1.doesPerimeterTouch(circle)) {
            wet = 1
          }
        }
        if (wet == 1) {
          return true
        }
        return false
      }
    }
    class PsychoSolar {
      constructor(guyIndex = 0, angle = 1, color = "red") {
        this.name = "PsychoSolar"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.angle = angle
        this.color = color
        this.radius = 200
        this.local = 1
        this.song = "psysnap.mp3"
        this.solar = 1
        this.moveAngle = 0
        this.id = Math.floor(Math.random() * 9000000)
      }
      move() {

      }
      draw() {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        if (this.local == 1) {
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
          this.lock = new Point(TIP_engine.x, TIP_engine.y)
        }
        this.angle = (new LineOP(players[this.guyIndex].body, this.lock)).angle() + Math.PI
        let p1 = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle + .5) * 100), players[this.guyIndex].body.y + (Math.sin(this.angle + .5) * 100), 10, "#FFAA22")
        let p2 = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle - .5) * 100), players[this.guyIndex].body.y + (Math.sin(this.angle - .5) * 100), 10, "#FFAA22")
        let end = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle) * 200), players[this.guyIndex].body.y + (Math.sin(this.angle) * 200), 10, "#FFAA22")
        let linkp1 = new LineOP(players[this.guyIndex].body, p1, "#FFAA22", 20)
        let linkp2 = new LineOP(players[this.guyIndex].body, p2, "#FFAA22", 20)
        let endp1 = new LineOP(end, p1, "#FFAA22", 20)
        let endp2 = new LineOP(end, p2, "#FFAA22", 20)
        p1.draw()
        p2.draw()
        linkp1.draw()
        linkp2.draw()
        endp1.draw()
        endp2.draw()
        end.draw()
        end.radius -= 3
        end.color = "white"
        end.draw()

        p2.radius -= 3
        p2.color = "white"
        p2.draw()
        p1.radius -= 3
        p1.color = "white"
        p1.draw()

        linkp1.color = "white"
        linkp1.width -= 3.5
        linkp1.draw()
        linkp2.color = "white"
        linkp2.width -= 3.5
        linkp2.draw()
        endp1.color = "white"
        endp1.width -= 3.5
        endp1.draw()
        endp2.color = "white"
        endp2.width -= 3.5
        endp2.draw()

      }
      doesPerimeterTouch(guybody) {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return false
        }
        if (this.local == 1) {
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
          this.lock = new Point(TIP_engine.x, TIP_engine.y)
        }
        let link = new LineOP(this, guybody)
        if (link.hypotenuse() > 265) {
          return false
        }
        this.angle = (new LineOP(players[this.guyIndex].body, this.lock)).angle() + Math.PI
        let p1 = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle + .5) * 100), players[this.guyIndex].body.y + (Math.sin(this.angle + .5) * 100), 10, "#FFAA22")
        let p2 = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle - .5) * 100), players[this.guyIndex].body.y + (Math.sin(this.angle - .5) * 100), 10, "#FFAA22")
        let end = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle) * 200), players[this.guyIndex].body.y + (Math.sin(this.angle) * 200), 10, "#FFAA22")
        let linkp1 = new LineOP(players[this.guyIndex].body, p1, "#FFAA22", 20)
        let linkp2 = new LineOP(players[this.guyIndex].body, p2, "#FFAA22", 20)
        let endp1 = new LineOP(end, p1, "#FFAA22", 20)
        let endp2 = new LineOP(end, p2, "#FFAA22", 20)

        let pile = [p1, p2, end, linkp1, linkp2, endp1, endp2]
        for (let t = 0; t < pile.length; t++) {
          if (pile[t].doesPerimeterTouch(guybody)) {
            return true
          }
        }

        return false
      }
    }

    class ButterStar {
      constructor(guyIndex = 0, angle = 1, color = "red") {
        this.name = "ButterStar"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.angle = angle
        this.angle2 = 0
        this.color = color
        this.radius = 200
        this.local = 1
        this.solar = 1
        this.song = "psysnap.mp3"
        this.moveAngle = 0
        this.id = Math.floor(Math.random() * 9000000)
      }
      move() {

      }
      draw() {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        if (this.local == 1) {
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
          this.lock = new Point(TIP_engine.x, TIP_engine.y)
        }

        this.angle = (new LineOP(players[this.guyIndex].body, this.lock)).angle() + Math.PI
        this.angle2 += 1 * (Math.PI / 24)
        let end = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle) * 200), players[this.guyIndex].body.y + (Math.sin(this.angle) * 200), 10, "#FFAA22")

        let a = 0
        for (let t = 0; t < 4; t++) {
          let link = new LineOP(end, new Point(end.x + (Math.cos(a + this.angle2) * 140), end.y + (Math.sin(a + this.angle2) * 140)), "Cyan", 6)
          a += Math.PI / 2
          link.draw()
        }


      }
      doesPerimeterTouch(guybody) {

        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return false
        }
        if (this.local == 1) {
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y
          this.lock = new Point(TIP_engine.x, TIP_engine.y)
        }
        let link = new LineOP(this, guybody)

        if (link.hypotenuse() > 375) {
          return false
        }

        this.angle = (new LineOP(players[this.guyIndex].body, this.lock)).angle() + Math.PI
        let end = new Circle(players[this.guyIndex].body.x + (Math.cos(this.angle) * 200), players[this.guyIndex].body.y + (Math.sin(this.angle) * 200), 10, "#FFAA22")

        let a = 0
        let pile = []
        for (let t = 0; t < 4; t++) {
          let link = new LineOP(end, new Point(end.x + (Math.cos(a + this.angle2) * 140), end.y + (Math.sin(a + this.angle2) * 140)), "red", 5)
          a += Math.PI / 2
          // link.draw()
          pile.push(link)

        }

        for (let t = 0; t < pile.length; t++) {
          if (pile[t].doesPerimeterTouch(guybody)) {
            return true
          }
        }

        return false
      }
    }

    class SolarFlares {
      constructor(guyIndex = 0, angle = 1, color = "red") {
        this.name = "SolarFlares"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.angle = angle
        this.color = color
        this.radius = 200
        this.local = 1
        this.solar = 1
        this.song = "slughorns.wav"
        this.moveAngle = 0
        this.id = Math.floor(Math.random() * 9000000)
      }

      move() { }
      draw() {
        this.angle = 0
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        for (let t = 0; t < 5; t++) {

          let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "red")
          let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
          let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 15, "yellow")
          // p.draw()
          // m.draw()

          // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
          // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
          // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
          // // p2.draw()
          // m2.draw()

          let l1 = new LineOP(p, k, "red", 6)
          l1.draw()
          let l2 = new LineOP(m, k, "red", 6)
          l2.draw()

          // let f1 = new LineOP(p2, k2, "gray", 6)
          // f1.draw()
          // let f2 = new LineOP(m2, k2, "gray", 6)
          // f2.draw()

          // k2.draw()

          k.draw()
          this.angle += (Math.PI * 2) / 5
        }
        this.angle = 0

      }
      doesPerimeterTouch(circle) {

        this.angle = 0
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          this.angle = 0
          return false
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }
        for (let t = 0; t < 5; t++) {
          let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "red")
          let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
          let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 15, "yellow")

          // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
          // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
          // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
          let l1 = new LineOP(p, k, "gray", 6)
          // l1.draw()
          let l2 = new LineOP(m, k, "gray", 6)
          // l2.draw()
          // let f1 = new LineOP(p2, k2, "gray", 6)
          // // f1.draw()
          // let f2 = new LineOP(m2, k2, "gray", 6)
          // // f2.draw()
          // k2.draw()
          // k.draw()
          // //////////////////////////////////////////////////////////console.log(circle)
          let wet = 0
          if (k.doesPerimeterTouch(circle)) {
            wet = 1
          }
          if (l1.doesPerimeterTouch(circle)) {
            wet = 1
          }
          if (l2.doesPerimeterTouch(circle)) {
            wet = 1
          }
          this.angle += (Math.PI * 2) / 5
        }
        // if(f1.doesPerimeterTouch(circle)){
        //     wet = 1
        // }
        // if(f2.doesPerimeterTouch(circle)){
        //     wet = 1
        // }
        let trapper = 0
        if (circle == players[0].body) {
          trapper = 1
        }
        if (wet == 1) {

          this.angle = 0
          this.guyIndex = champids.indexOf(this.guyid)

          if (players[this.guyIndex]) {
          } else {
            this.angle = 0
            return false
          }
          this.x = players[this.guyIndex].body.x
          this.y = players[this.guyIndex].body.y

          let link = new LineOP(this, circle)
          if (link.hypotenuse() > this.radius + 64) {
            return false
          }
          for (let t = 0; t < 5; t++) {

            let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "red")
            let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
            let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 15, "yellow")

            // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
            // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
            // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
            let l1 = new LineOP(p, k, "gray", 6)
            // l1.draw()
            let l2 = new LineOP(m, k, "gray", 6)
            for (let z = 0; z < 10; z++) {
              for (let k = 0; k < walls.length; k++) {
                walls[k].doesPerimeterTouch(circle)
              }
              let pc1 = l1.crashPoint(circle)
              let pc2 = l2.crashPoint(circle)
              // let pc3 = f1.crashPoint(circle)
              // let pc4 = f2.crashPoint(circle)
              if (trapper == 0) {
                if (pc1.length > 0) {
                  let l = new LineOP(pc1[0], circle)
                  circle.x -= Math.cos(l.angle()) * 3
                  circle.y -= Math.sin(l.angle()) * 3
                } else if (pc2.length > 0) {
                  let l = new LineOP(pc2[0], circle)
                  circle.x -= Math.cos(l.angle()) * 3
                  circle.y -= Math.sin(l.angle()) * 3
                }

              } else {

                if (pc1.length > 0) {
                  let l = new LineOP(pc1[0], circle)
                  let a = l.angle()
                  circle.x -= Math.cos(a) * 3
                  circle.y -= Math.sin(a) * 3
                  //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                  //translator.x += Math.cos(a) * 3
                  //translator.y += Math.sin(a) * 3
                } else if (pc2.length > 0) {
                  let l = new LineOP(pc2[0], circle)
                  let a = l.angle()
                  circle.x -= Math.cos(a) * 3
                  circle.y -= Math.sin(a) * 3
                  //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                  //translator.x += Math.cos(a) * 3
                  //translator.y += Math.sin(a) * 3
                }
              }
              // }else  if(pc3.length > 0){
              //     circle.x -= (Math.sign(pc3[0].x - circle.x))*1
              //     circle.y -= (Math.sign(pc3[0].y - circle.y))*1
              // }else  if(pc4.length > 0){
              //     circle.x -= (Math.sign(pc4[0].x - circle.x))*1
              //     circle.y -= (Math.sign(pc4[0].y - circle.y))*1
              // }

              for (let k = 0; k < walls.length; k++) {
                walls[k].doesPerimeterTouch(circle)
              }
            }



            this.angle += (Math.PI * 2) / 5
          }

          this.angle = 0
          return true
        }
        this.angle = 0
        return false

      }

    }



    class BoomSpike {
      constructor(guyIndex = 0, length = 1, angle = 1, color = "red") {
        this.name = "BoomSpike"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        this.angle = angle
        this.color = color
        this.radius = length
        this.local = 1
        this.solar = 1
        this.song = "slughorns.wav"
        this.moveAngle = 1
        this.id = Math.floor(Math.random() * 9000000)
      }

      move() { }
      draw() {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 15, "yellow")
        // p.draw()
        // m.draw()

        // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        // // p2.draw()
        // m2.draw()

        let l1 = new LineOP(p, k, "red", 6)
        l1.draw()
        let l2 = new LineOP(m, k, "red", 6)
        l2.draw()

        // let f1 = new LineOP(p2, k2, "gray", 6)
        // f1.draw()
        // let f2 = new LineOP(m2, k2, "gray", 6)
        // f2.draw()

        // k2.draw()

        k.draw()

      }
      doesPerimeterTouch(circle) {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }
        let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "red")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "red")
        let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 15, "yellow")

        // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        let l1 = new LineOP(p, k, "gray", 6)
        // l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        // l2.draw()
        // let f1 = new LineOP(p2, k2, "gray", 6)
        // // f1.draw()
        // let f2 = new LineOP(m2, k2, "gray", 6)
        // // f2.draw()
        // k2.draw()
        // k.draw()
        // //////////////////////////////////////////////////////////console.log(circle)
        let wet = 0
        if (k.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        // if(f1.doesPerimeterTouch(circle)){
        //     wet = 1
        // }
        // if(f2.doesPerimeterTouch(circle)){
        //     wet = 1
        // }
        let trapper = 0
        if (circle == players[0].body) {
          trapper = 1
        }
        if (wet == 1) {
          for (let z = 0; z < 10; z++) {
            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
            let pc1 = l1.crashPoint(circle)
            let pc2 = l2.crashPoint(circle)
            // let pc3 = f1.crashPoint(circle)
            // let pc4 = f2.crashPoint(circle)
            if (trapper == 0) {
              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                circle.x -= Math.cos(l.angle()) * 3
                circle.y -= Math.sin(l.angle()) * 3
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                circle.x -= Math.cos(l.angle()) * 3
                circle.y -= Math.sin(l.angle()) * 3
              }

            } else {

              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 3
                circle.y -= Math.sin(a) * 3
                //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                //translator.x += Math.cos(a) * 3
                //translator.y += Math.sin(a) * 3
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 3
                circle.y -= Math.sin(a) * 3
                //canvas_context.translate(Math.cos(a) * 3, Math.sin(a) * 3)
                //translator.x += Math.cos(a) * 3
                //translator.y += Math.sin(a) * 3
              }
            }
            // }else  if(pc3.length > 0){
            //     circle.x -= (Math.sign(pc3[0].x - circle.x))*1
            //     circle.y -= (Math.sign(pc3[0].y - circle.y))*1
            // }else  if(pc4.length > 0){
            //     circle.x -= (Math.sign(pc4[0].x - circle.x))*1
            //     circle.y -= (Math.sign(pc4[0].y - circle.y))*1
            // }

            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
          }



          return true
        }
        return false
      }
    }

    class MeleeSpike {
      constructor(guyIndex = 0, length = 1, angle = 1, color = "red") { //refactor
        this.name = "MeleeSpike"
        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.x = this.guyIndex.x
        this.y = this.guyIndex.y
        this.angle = angle
        this.color = color
        this.solar = 1
        this.radius = length
        this.local = 1
        this.song = "meleehit.wav"
        this.id = Math.floor(Math.random() * 9000000)
      }

      move() { }
      draw() {

        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "gray")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "gray")
        let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 6, "gray")
        // p.draw()
        // m.draw()

        // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        // // p2.draw()
        // m2.draw()

        let l1 = new LineOP(p, k, "gray", 6)
        l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        l2.draw()

        // let f1 = new LineOP(p2, k2, "gray", 6)
        // f1.draw()
        // let f2 = new LineOP(m2, k2, "gray", 6)
        // f2.draw()

        // k2.draw()

        k.draw()

      }
      doesPerimeterTouch(circle) {
        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return false
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }
        let p = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "gray")
        let m = new Circle(this.x - (Math.cos(this.angle - .5) * 8), this.y - (Math.sin(this.angle - .5) * 8), 3, "gray")
        let k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 6, "gray")

        // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 8), this.y - (Math.sin(this.angle + 1) * 8), 3, "blue")
        // let m2 = new Circle(this.x - (Math.cos(this.angle + .5) * 8), this.y - (Math.sin(this.angle + .5) * 8), 3, "blue")
        // let k2 = new Circle(this.x - (Math.cos(this.angle + .75) * this.radius), this.y - (Math.sin(this.angle + .75) * this.radius), 3, "white")
        let l1 = new LineOP(p, k, "gray", 6)
        // l1.draw()
        let l2 = new LineOP(m, k, "gray", 6)
        // l2.draw()
        // let f1 = new LineOP(p2, k2, "gray", 6)
        // // f1.draw()
        // let f2 = new LineOP(m2, k2, "gray", 6)
        // // f2.draw()
        // k2.draw()
        // k.draw()
        // //////////////////////////////////////////////////////////console.log(circle)
        let wet = 0
        if (k.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l1.doesPerimeterTouch(circle)) {
          wet = 1
        }
        if (l2.doesPerimeterTouch(circle)) {
          wet = 1
        }
        // if(f1.doesPerimeterTouch(circle)){
        //     wet = 1
        // }
        // if(f2.doesPerimeterTouch(circle)){
        //     wet = 1
        // }
        let trapper = 0
        if (circle == players[0].body) {
          trapper = 1
        }
        if (wet == 1) {
          for (let z = 0; z < 10; z++) {
            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }




            let pc1 = l1.crashPoint(circle)
            let pc2 = l2.crashPoint(circle)
            // let pc3 = f1.crashPoint(circle)
            // let pc4 = f2.crashPoint(circle)
            if (trapper == 0) {
              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                circle.x -= Math.cos(l.angle()) * 2
                circle.y -= Math.sin(l.angle()) * 2
              }

            } else {

              if (pc1.length > 0) {
                let l = new LineOP(pc1[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              } else if (pc2.length > 0) {
                let l = new LineOP(pc2[0], circle)
                let a = l.angle()
                circle.x -= Math.cos(a) * 2
                circle.y -= Math.sin(a) * 2
                //canvas_context.translate(Math.cos(a) * 2, Math.sin(a) * 2)
                //translator.x += Math.cos(a) * 2
                //translator.y += Math.sin(a) * 2
              }
            }
            // }else  if(pc3.length > 0){
            //     circle.x -= (Math.sign(pc3[0].x - circle.x))*1
            //     circle.y -= (Math.sign(pc3[0].y - circle.y))*1
            // }else  if(pc4.length > 0){
            //     circle.x -= (Math.sign(pc4[0].x - circle.x))*1
            //     circle.y -= (Math.sign(pc4[0].y - circle.y))*1
            // }

            for (let k = 0; k < walls.length; k++) {
              walls[k].doesPerimeterTouch(circle)
            }
          }



          return true
        }
        return false
      }
    }
    class TongueSpike {
      constructor(guyIndex = 0, length = 0, angle = 0, color = "red", guy = {}) {
        this.name = "TongueSpike"

        this.guyIndex = guyIndex
        this.guyid = players[this.guyIndex].id
        this.angle = angle
        this.color = color
        this.radius = length
        this.local = 1
        this.id = Math.floor(Math.random() * 9000000)
      }
      move() { }
      draw() {
        // this.x = this.track.x
        // this.y = this.track.y


        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return false
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y


        this.k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 13, "blue")
        this.p = new Circle(this.x - (Math.cos(this.angle) * 16), this.y - (Math.sin(this.angle) * 16), 3, "blue")
        this.p.x = this.x - (Math.cos(this.angle) * 16)
        this.p.y = this.y - (Math.sin(this.angle) * 16)
        // p.draw()
        // m.draw()
        if (this.radius >= this.maxDis) {
          this.growth = .85
        }
        this.k.x = this.x - (Math.cos(this.angle) * this.radius)
        this.k.y = this.y - (Math.sin(this.angle) * this.radius)
        // let p2 = new Circle(this.x - (Math.cos(this.angle + 1) * 16), this.y - (Math.sin(this.angle + 1) * 16), 3, "blue")
        // let k2 = new Circle(this.x - (Math.cos(this.angle ) * this.radius), this.y - (Math.sin(this.angle + .875) * this.radius), 13, "blue")
        // p2.draw()
        // m2.draw()

        let l1 = new LineOP(this.p, this.k, "Blue", 6)
        l1.draw()

        // let f1 = new LineOP(p2, k2, "Blue", 6)
        // f1.draw()
        // let f2 = new LineOP(m2, k2, "Blue", 6)
        // f2.draw()

        // k2.draw()

        this.k.draw()

      }

      doesPerimeterTouch(circle) {

        this.guyIndex = champids.indexOf(this.guyid)

        if (players[this.guyIndex]) {
        } else {
          return false
        }
        this.x = players[this.guyIndex].body.x
        this.y = players[this.guyIndex].body.y
        let link = new LineOP(this, circle)
        if (link.hypotenuse() > this.radius + 64) {
          return false
        }

        this.k = new Circle(this.x - (Math.cos(this.angle) * this.radius), this.y - (Math.sin(this.angle) * this.radius), 13, "blue")
        this.p = new Circle(this.x - (Math.cos(this.angle) * 16), this.y - (Math.sin(this.angle) * 16), 3, "blue")
        this.k.x = this.x - (Math.cos(this.angle) * this.radius)
        this.k.y = this.y - (Math.sin(this.angle) * this.radius)
        let l1 = new LineOP(this.p, this.k, "Blue", 6)
        l1.draw()

        if (l1.doesPerimeterTouch(circle)) {
          return true
        }
        if (this.k.doesPerimeterTouch(circle)) {
          return true
        }

        return false
      }
    }



    let gearItems = []

    for (let t = 0; t < 46; t++) {
      const ing = new Image()
      if (t < 10) {
        ing.src = `https://ditzbitz.com/gearItem0000${t}.png`
      } else {
        ing.src = `https://ditzbitz.com/gearItem000${t}.png`
      }
      gearItems.push(ing)
    }



    class StoreUI {
      constructor(team) {
        this.root = team.body
        this.shell = new Rectangle(this.root.x, this.root.y, 100, 100, "gray")
        this.buttons = [new Rectangle(this.shell.x, this.shell.y, 50, 50, "black"), new Rectangle(this.shell.x + 50, this.shell.y, 50, 50, "black"), new Rectangle(this.shell.x, this.shell.y + 50, 50, 50, "black"), new Rectangle(this.shell.x + 50, this.shell.y + 50, 50, 50, "black")]
      }
      draw() {
        this.shell.draw()
        for (let t = 0; t < this.buttons.length; t++) {
          this.buttons[t].draw()
          canvas_context.drawImage(gearItems[t], 0, 0, gearItems[t].height, gearItems[t].height, this.buttons[t].x, this.buttons[t].y, 50, 50)
        }
      }
      check(point) {
        for (let t = 0; t < this.buttons.length; t++) {
          if (this.buttons[t].isPointInside(point)) {
            if (players[0].gold >= 500) {
              if (players[0].gear[0].type == -1) {
                players[0].gear[0] = new Gear(t, players[0], 0)
                players[0].gold -= 500
                return true
                continue
              } else if (players[0].gear[1].type == -1) {
                players[0].gear[1] = new Gear(t, players[0], 1)
                players[0].gold -= 500
                return true
                continue
              } else if (players[0].gear[2].type == -1) {
                players[0].gear[2] = new Gear(t, players[0], 2)
                players[0].gold -= 500
                return true
                continue
              } else if (players[0].gear[3].type == -1) {
                players[0].gear[3] = new Gear(t, players[0], 3)
                players[0].gold -= 500
                return true
                continue
              }
            }
            return true
          }
        }
      }

      toolcheck(point) {
        for (let t = 0; t < this.buttons.length; t++) {
          if (this.buttons[t].isPointInside(point)) {
            // if (players[0].gold >= 500) {
            if (t == 0) {
              let tool = {}
              tool.lines = []
              tool.fact = 1
              tool.lines.push("500g: Whumpump Tooth")
              tool.lines.push("Damage: " + "40" + "%")
              tool.lines.push("Armor: " + "0" + "%")
              tool.lines.push("Speed: " + "2.5" + "%")
              tool.lines.push("Healthregen: " + "0" + "%")
              tool.lines.push("Manaregen: " + "0" + "%")
              return tool
            } else if (t == 1) {
              let tool = {}

              tool.lines = []
              tool.fact = 1
              tool.lines.push("500g: Wrench Toast")
              tool.lines.push("Damage: " + "25" + "%")
              tool.lines.push("Armor: " + "0" + "%")
              tool.lines.push("Speed: " + "0" + "%")
              tool.lines.push("Healthregen: " + "50" + "%")
              tool.lines.push("Manaregen: " + "50" + "%")
              return tool
            } else if (t == 2) {
              let tool = {}

              tool.lines = []
              tool.fact = 1
              tool.lines.push("500g: Wire Cutters")
              tool.lines.push("Damage: " + "15" + "%")
              tool.lines.push("Armor: " + "15" + "%")
              tool.lines.push("Speed: " + "5" + "%")
              tool.lines.push("Healthregen: " + "0" + "%")
              tool.lines.push("Manaregen: " + "0" + "%")
              return tool
            } else if (t == 3) {
              let tool = {}

              tool.lines = []
              tool.fact = 1
              tool.lines.push("500g: Vitality Vestaments")
              tool.lines.push("Damage: " + "0" + "%")
              tool.lines.push("Armor: " + "10" + "%")
              tool.lines.push("Speed: " + "5" + "%")
              tool.lines.push("Healthregen: " + "75" + "%")
              tool.lines.push("Manaregen: " + "75" + "%")
              return tool
            }
            // }
          }
        }

        return { fact: false }
      }
    }

    class Gear {
      constructor(type, guy, index) {
        this.guy = guy
        this.type = type
        this.index = index
        this.damage = 1
        this.armor = 1
        this.speed = 1
        this.manaregen = 1
        this.healthregen = 1
        if (this.type == -1) {
          this.name = "Empty"
          return
        }
        if (this.type == 0) {
          this.name = "Whumpump Tooth"
          this.speed = 1.025
          this.damage = 1.4
        }
        if (this.type == 1) {
          this.name = "Wrench Toast"
          this.damage = 1.25
          this.healthregen = 1.5
          this.manaregen = 1.5
        }
        if (this.type == 2) {
          this.name = "Wire Cutter"
          this.damage = 1.15
          this.armor = 1.15
          this.speed = 1.05
        }
        if (this.type == 3) {
          this.name = "Vitality Vestments"
          this.healthregen = 1.75
          this.speed = 1.05
          this.armor = 1.1
          this.manaregen = 1.75
        }
        // this.reset()
        this.balance()
      }
      reset() {
        this.guy.gaerboosts = {}
        this.guy.gaerboosts.damage = 1
        this.guy.gaerboosts.armor = 1
        this.guy.gaerboosts.speed = 1
        this.guy.gaerboosts.healthregen = 1
        this.guy.gaerboosts.manaregen = 1
      }
      balance() {
        this.guy.gaerboosts.damage *= this.damage
        this.guy.gaerboosts.armor *= this.armor
        this.guy.gaerboosts.speed *= this.speed
        this.guy.gaerboosts.manaregen *= this.manaregen
        this.guy.gaerboosts.healthregen *= this.healthregen
      }
      toolcheck(point) {
        this.x = (-translator.x) + (60 * this.index)
        this.y = (-translator.y) + 660
        this.box = new Rectangle(this.x, this.y, 60, 60, "gray")
        if (this.box.isPointInside(point)) {
          let tool = {}
          tool.lines = []
          tool.fact = 1
          tool.lines.push(this.name)
          tool.lines.push("Damage: " + Math.round((this.damage - 1) * 100) + "%")
          tool.lines.push("Armor: " + Math.round((this.armor - 1) * 100) + "%")
          tool.lines.push("Speed: " + Math.round((this.speed - 1) * 100) + "%")
          tool.lines.push("Healthregen: " + Math.round((this.healthregen - 1) * 100) + "%")
          tool.lines.push("Manaregen: " + Math.round((this.manaregen - 1) * 100) + "%")
          return tool
        }
        return false
      }
      subcheck(point) {
        this.x = (-translator.x) + (60 * this.index)
        this.y = (-translator.y) + 660
        this.box = new Rectangle(this.x, this.y, 60, 60, "gray")
        if (this.box.isPointInside(point)) {
          return true
        }

        return false
      }

      check(point) {
        this.x = (-translator.x) + (60 * this.index)
        this.y = (-translator.y) + 660
        this.box = new Rectangle(this.x, this.y, 60, 60, "gray")
        if (this.type != -1) {
          if (this.box.isPointInside(point)) {
            if (storeUI1.shop == 1 || storeUI2.shop == 1) {
              this.type = -1
              this.damage = 1
              this.armor = 1
              this.speed = 1
              this.manaregen = 1
              this.healthregen = 1
              this.guy.gold += 500
              if (this.type == -1) {
                this.name = "Empty"
                return true
              }
              return true
            }
            return true
          }
        }

        return false
      }
      draw() {
        this.x = (-translator.x) + (60 * this.index)
        this.y = (-translator.y) + 660
        this.box = new Rectangle(this.x, this.y, 60, 60, "gray")
        this.box.draw()
        if (this.type != -1) {
          let rat = gearItems[this.type].width / gearItems[this.type].height
          canvas_context.drawImage(gearItems[this.type], 0, 0, gearItems[this.type].height, gearItems[this.type].height, this.x, this.y, 60, 60)
        }
      }
    }

    class DeathPop {
      constructor(x, y, money) {
        this.pops = []
        this.money = money
        this.life = 9
        this.a = 0
        this.step = (Math.PI * 2) / 9
        for (let t = 0; t < 9; t++) {
          let dot = new Circle(x, y, 10, "black", Math.cos(this.a) * 15, Math.sin(this.a) * 15)
          this.pops.push(dot)
          this.a += this.step
        }
        this.x = x
        this.y = y
      }
      draw() {
        for (let t = 0; t < this.pops.length; t++) {
          this.pops[t].radius *= .95
          this.pops[t].draw()
          this.pops[t].move()
        }
        canvas_context.fillStyle = "gold"
        canvas_context.font = "30px comic sans ms"
        canvas_context.fillText(this.money, this.x - 30, this.y)
        this.life--
      }
    }

    let translator = { x: 0, y: 0 }
    //canvas_context.translate(-360 - (1280 - (640 - 360)), -360 - 720)
    //translator.x -= 360 + (1280 - (640 - 360))
    //translator.y -= 360 + 720

    let worldpops = []


    class Champ {
      constructor(type, team) {
        this.smackline = 0
        this.gaerboosts = {}
        this.gaerboosts.damage = 1
        this.gaerboosts.armor = 1
        this.gaerboosts.speed = 1
        this.gaerboosts.healthregen = 1
        this.gaerboosts.manaregen = 1
        this.hitlane = 0
        this.tar = 1
        this.activeArts = []
        this.id = Math.floor(Math.random() * 9000000)
        this.meleeRange = this.meleeRangeMaker(type)
        this.gold = 360
        this.goldtotal = this.gold
        this.team = team
        this.health = this.healthMaker(type)
        this.mana = this.manaMaker(type)
        this.healthRegen = this.healthRegenMaker(type)
        this.manaRegen = this.manaRegenMaker(type)
        this.maxhealth = this.health
        this.maxmana = this.mana
        let wet = 0
        let ids = []
        for (let t = 0; t < team.players.length; t++) {
          ids.push(team.players.id)
        }
        if (ids.includes(this.id)) {
          team.players.push(this)
        }
        this.type = type
        this.gear = [new Gear(-1, this, 0), new Gear(-1, this, 1), new Gear(-1, this, 2), new Gear(-1, this, 3)]
        this.abilities = [this.power1(this.type), this.power2(this.type), this.power3(this.type), this.power4(this.type)]
        this.body = new Circle((1280 - (640 - 360)) * 2, 720 * 2, 32, "red")
        this.basicAttack = this.makeBasic()
        this.goal = this.body
        if (this.type == -1) {
          this.body.radius = 20
          this.body.y += 200
          this.body.x -= 400
        }
        this.cooldowns = [0, 0, 0, 0, 0]
        this.UI = [new Rectangle(400, 660, 60, 60, "#FF00FF"), new Rectangle(460, 660, 60, 60, "#FFff00"), new Rectangle(520, 660, 60, 60, "#00FFff"), new Rectangle(580, 660, 60, 60, "#FFFFFF")]
        this.sleep = -1
        this.step = 0
        this.rate = 0
        this.chunk = 4
        this.speed = this.speedMaker(this.type)
        this.boosts = []
        this.drops = []
        this.slimeToggle = -1
        this.slowedByFloor = 1
        this.selected = 0
      }
      toolcheck(point) {

        this.UI = [new Rectangle(240, 660, 60, 60, "#880000"), new Rectangle(300, 660, 60, 60, "#880000"), new Rectangle(360, 660, 60, 60, "#880000"), new Rectangle(420, 660, 60, 60, "#880000")]

        for (let t = 0; t < this.UI.length; t++) {
          this.UI[t].x -= translator.x
          this.UI[t].y -= translator.y
          if (this.UI[t].isPointInside(point)) {
            let tool = {}
            tool.lines = []
            tool.fact = 1
            if (this.type == 0) {
              if (t == 0) {
                tool.lines.push("Psyblast")
                tool.lines.push("130 Mana")
                tool.lines.push("400 Frame Cooldown")
                tool.lines.push("A powerful beam/wave")
              } else if (t == 1) {
                tool.lines.push("Shockwave")
                tool.lines.push("60 Mana")
                tool.lines.push("40 Frame Cooldown")
                tool.lines.push("A growing shockwave")
              } else if (t == 2) {
                tool.lines.push("Sleep/Awake")
                tool.lines.push("Toggle for Mana and Health")
                tool.lines.push("80 Frame Cooldown")
                tool.lines.push("Toggle your moveset")
                tool.lines.push("by sleeping or waking up")
              } else if (t == 3) {
                tool.lines.push("Shield")
                tool.lines.push("100 mana")
                tool.lines.push("300-400 frame cooldown")
                tool.lines.push("Shield self and minions")
              }
            }
            if (this.type == 1) {
              if (t == 0) {
                tool.lines.push("Slugmax")
                tool.lines.push("100 Mana")
                tool.lines.push("400 Frame Cooldown")
                tool.lines.push("Drop a big pile of slime")
                tool.lines.push("That slows and damages")
              } else if (t == 1) {
                tool.lines.push("Mating Horns")
                tool.lines.push("60 Mana")
                tool.lines.push("40 Frame Cooldown")
                tool.lines.push("Extend damaging horns")
              } else if (t == 2) {
                tool.lines.push("Rush")
                tool.lines.push("25 Mana")
                tool.lines.push("80 Frame Cooldown")
                tool.lines.push("Gain movement speed")
              } else if (t == 3) {
                tool.lines.push("Drop Slime")
                tool.lines.push("10 mana/drop")
                tool.lines.push("10 Frame/drop")
                tool.lines.push("30 frame toggle")
                tool.lines.push("Leave a trail of damage")
              }
            }
            if (this.type == 2) {
              if (t == 0) {
                tool.lines.push("Spit Egg")
                tool.lines.push("60 Mana")
                tool.lines.push("200 Frame Cooldown")
                tool.lines.push("Long range projectile")
              } else if (t == 1) {
                tool.lines.push("Tongue Snatch")
                tool.lines.push("70 Mana")
                tool.lines.push("40 Frame Cooldown")
                tool.lines.push("Bring your enemy to you")
                tool.lines.push("By grabbing them")
              } else if (t == 2) {
                tool.lines.push("Rush")
                tool.lines.push("25 Mana")
                tool.lines.push("80 Frame Cooldown")
                tool.lines.push("Gain movement speed")
              } else if (t == 3) {
                tool.lines.push("Ground Pound")
                tool.lines.push("50 Mana")
                tool.lines.push("40 frame cooldown")
                tool.lines.push("Send out a circular shockwave")
              }
            }
            if (this.type == 3) {
              if (t == 0) {
                tool.lines.push("Big Bomb")
                tool.lines.push("100 Mana")
                tool.lines.push("120 Frame Cooldown")
                tool.lines.push("Long range projectile")
              } else if (t == 1) {
                tool.lines.push("Minefield")
                tool.lines.push("100 Mana")
                tool.lines.push("200 Frame Cooldown")
                tool.lines.push("Lay out a minefield")
              } else if (t == 2) {
                tool.lines.push("Rocket Zoom")
                tool.lines.push("30 Mana, 10% max health")
                tool.lines.push("150 Frame Cooldown")
                tool.lines.push("Gain movement speed")
              } else if (t == 3) {
                tool.lines.push("Geiger Slam")
                tool.lines.push("100 Mana")
                tool.lines.push("400 frame cooldown")
                tool.lines.push("A damaging rod to use")
              }
            }
            if (this.type == 4) {
              if (t == 0) {
                tool.lines.push("Healing Beam")
                tool.lines.push("100 Mana")
                tool.lines.push("120 Frame Cooldown")
                tool.lines.push("Heal minions and team")
              } else if (t == 1) {
                tool.lines.push("Grapeshot")
                tool.lines.push("10 mana/drop")
                tool.lines.push("16 Frame/drop")
                tool.lines.push("20 frame toggle")
                tool.lines.push("Short range projectile")
              } else if (t == 2) {
                tool.lines.push("Lemon Fingers")
                tool.lines.push("45 Mana")
                tool.lines.push("200 Frame Cooldown")
                tool.lines.push("Extend damaging fingers")
              } else if (t == 3) {
                tool.lines.push("Battle Control")
                tool.lines.push("Gain 40 Mana, heal near allies")
                tool.lines.push("500 frame cooldown")
                tool.lines.push("A shockwave of health / harm")
              }
            }
            if (this.type == 5) {
              if (t == 0) {
                tool.lines.push("Burnout")
                tool.lines.push("50 Mana, 25 health")
                tool.lines.push("40 Frame Cooldown")
                tool.lines.push("A slow large shockwave")
              } else if (t == 1) {
                tool.lines.push("Fusion")
                tool.lines.push("For 120 Mana trade 50 health")
                tool.lines.push("80 frame toggle")
                tool.lines.push("Trade health for mana")
              } else if (t == 2) {
                tool.lines.push("Psychosolar")
                tool.lines.push("100 Mana")
                tool.lines.push("300 Frame Cooldown")
                tool.lines.push("A bifurcated beam")
              } else if (t == 3) {
                tool.lines.push("Solar Flares")
                tool.lines.push("100 Mana")
                tool.lines.push("280 frame cooldown")
                tool.lines.push("Five pointy protectors")
              }
            }
            if (this.type == 6) {
              if (t == 0) {
                tool.lines.push("Banana Boundary")
                tool.lines.push("50 Mana")
                tool.lines.push("400 Frame Cooldown")
                tool.lines.push("A rotating shell of defense")
              } else if (t == 1) {
                tool.lines.push("Bananarang")
                tool.lines.push("40 Mana")
                tool.lines.push("60 frame cooldown")
                tool.lines.push("A boomerang projectile")
              } else if (t == 2) {
                tool.lines.push("Rush")
                tool.lines.push("25 Mana")
                tool.lines.push("80 Frame Cooldown")
                tool.lines.push("Gain movement speed")
              } else if (t == 3) {
                tool.lines.push("Banana Field")
                tool.lines.push("100 Mana")
                tool.lines.push("240 frame cooldown")
                tool.lines.push("A curved line of mines")
              }
            }
            if (this.type == 7) {
              if (t == 0) {
                tool.lines.push("Ϫlitch Ring")
                tool.lines.push("60 Mana")
                tool.lines.push("140 Frame Cooldown")
                tool.lines.push("A rotating shell of defense")
              } else if (t == 1) {
                tool.lines.push("Ϫlitch Zone")
                tool.lines.push("100 Mana")
                tool.lines.push("280 frame cooldown")
                tool.lines.push("A deadly X shaped spot")
              } else if (t == 2) {
                tool.lines.push("Self Heal")
                tool.lines.push("50 Mana")
                tool.lines.push("300 Frame Cooldown")
                tool.lines.push("Heal 200 health")
              } else if (t == 3) {
                tool.lines.push("Warp")
                tool.lines.push("25 Mana")
                tool.lines.push("25 Health")
                tool.lines.push("60 frame cooldown")
                tool.lines.push("Teleport a distance")
              }
            }

            if (this.type == 8) {
              if (t == 0) {
                tool.lines.push("Spawn Gumnut")
                tool.lines.push("35 Mana")
                tool.lines.push("180 Frame Cooldown")
                tool.lines.push("Gumnut minion fights for you")
              } else if (t == 1) {
                tool.lines.push("Manterfly Arena")
                tool.lines.push("75 Mana")
                tool.lines.push("280 frame cooldown")
                tool.lines.push("A delay ring")
              } else if (t == 2) {
                tool.lines.push("Spinning Wingblade")
                tool.lines.push("100 Mana")
                tool.lines.push("480 Frame Cooldown")
                tool.lines.push("Heal 200 health")
              } else if (t == 3) {
                tool.lines.push("Healing Slow")
                tool.lines.push("Gain 10% mana and health")
                tool.lines.push("Slow by half")
                tool.lines.push("80 frame cooldown")
              }
            }
            if (this.type == 9) {
              if (t == 0) {
                tool.lines.push("Crystal Beam")
                tool.lines.push("40 Mana")
                tool.lines.push("80 Frame Cooldown")
                tool.lines.push("A powerful beam")
              } else if (t == 1) {
                tool.lines.push("Scouting Ball")
                tool.lines.push("40 Mana")
                tool.lines.push("60 frame cooldown")
                tool.lines.push("A boomerang projectile")
              } else if (t == 2) {
                tool.lines.push("Light Attack")
                tool.lines.push("100 Mana")
                tool.lines.push("300 Frame Cooldown")
                tool.lines.push("A bifurcated beam")
              } else if (t == 3) {
                tool.lines.push("Crystal Healing Beam")
                tool.lines.push("100 Mana")
                tool.lines.push("120 Frame Cooldown")
                tool.lines.push("Heal minions and team")
              }
            }
            if (this.type == 10) {
              if (t == 0) {
                tool.lines.push("Rocket Rush")
                tool.lines.push("25 Mana, 25 Health")
                tool.lines.push("60 Frame Cooldown")
                tool.lines.push("Speed up, drop exhaust")
              } else if (t == 1) {
                tool.lines.push("Defining Ring")
                tool.lines.push("75 Mana")
                tool.lines.push("280 frame cooldown")
                tool.lines.push("An offensive ring")
              } else if (t == 2) {
                tool.lines.push("Boom Rush")
                tool.lines.push("25 Mana")
                tool.lines.push("200 Frame Cooldown")
                tool.lines.push("Speed up, drop exhaust")
              } else if (t == 3) {
                tool.lines.push("Second Melee")
                tool.lines.push("Melee on command")
              }
            }

            return tool
          }
        }
        return false
      }
      makeBasic() {
        return this.unitmeleeChamp
      }
      manaMaker(type) {
        this.tempHealth = 0
        this.mana = 100
        if (type == -1) {
          this.mana = 400
        }
        if (type == 0) {
          this.mana = 720
        }
        if (type == 1) {
          this.mana = 360
        }
        if (type == 2) {
          this.mana = 475
        }
        if (type == 3) {
          this.mana = 550
        }
        if (type == 4) {
          this.mana = 333
        }
        if (type == 4) {
          this.mana = 333
        }
        if (type == 5) {
          this.mana = 666
        }
        if (type == 6) {
          this.mana = 420
        }
        if (type == 7) {
          this.mana = 531
        }
        if (type == 8) {
          this.mana = 450
        }
        if (type == 9) {
          this.mana = 500
        }
        if (type == 10) {
          this.mana = 675
        }
        return this.mana
      }

      healthMaker(type) {
        this.tempHealth = 0
        this.health = 100
        if (type == -1) {
          this.health = 400
        }
        if (type == 0) {
          this.health = 500
        }
        if (type == 1) {
          this.health = 920
        }
        if (type == 2) {
          this.health = 650
        }
        if (type == 3) {
          this.health = 600
        }
        if (type == 4) {
          this.health = 1024
        }
        if (type == 5) {
          this.health = 451
        }
        if (type == 6) {
          this.health = 550
        }
        if (type == 7) {
          this.health = 999
        }
        if (type == 8) {
          this.health = 720
        }
        if (type == 9) {
          this.health = 575
        }
        if (type == 10) {
          this.health = 464
        }
        return this.health
      }
      meleeRangeMaker(type) {
        this.tempMeleeRange = 0
        if (type == -1) {
          this.meleeRange = 64
        }
        if (type == 0) {
          this.meleeRange = 110
        }
        if (type == 1) {
          this.meleeRange = 80
        }
        if (type == 2) {
          this.meleeRange = 90
        }
        if (type == 3) {
          this.meleeRange = 90
        }
        if (type == 4) {
          this.meleeRange = 105
        }
        if (type == 5) {
          this.meleeRange = 165
        }
        if (type == 6) {
          this.meleeRange = 100
        }
        if (type == 7) {
          this.meleeRange = 75
        }
        if (type == 8) {
          this.meleeRange = 90
        }
        if (type == 9) {
          this.meleeRange = 101
        }
        if (type == 10) {
          this.meleeRange = 150
        }
        return this.meleeRange
      }
      healthRegenMaker(type) {
        this.tempHealthRegen = 0
        if (type == -1) {
          this.healthRegen = 0
        }
        if (type == 0) {
          this.healthRegen = 4 / 100
        }
        if (type == 1) {
          this.healthRegen = 2 / 100
        }
        if (type == 2) {
          this.healthRegen = 3 / 100
        }
        if (type == 3) {
          this.healthRegen = 3 / 100
        }
        if (type == 4) {
          this.healthRegen = 1 / 100
        }
        if (type == 5) {
          this.healthRegen = 13 / 100 
        }
        if (type == 6) {
          this.healthRegen = 7 / 100
        }
        if (type == 7) {
          this.healthRegen = 5 / 100
        }
        if (type == 8) {
          this.healthRegen = 5 / 100
        }
        if (type == 9) {
          this.healthRegen = 3.5 / 100
        }
        if (type == 10) {
          this.healthRegen = 11 / 100
        }
        return this.healthRegen
      }
      manaRegenMaker(type) {
        this.tempManaRegen = 0
        if (type == -1) {
          this.manaRegen = 0
        }
        if (type == 0) {
          this.manaRegen = .15
        }
        if (type == 1) {
          this.manaRegen = .1
        }
        if (type == 2) {
          this.manaRegen = .12
        }
        if (type == 3) {
          this.manaRegen = .1875
        }
        if (type == 4) {
          this.manaRegen = .05
        }
        if (type == 5) {
          this.manaRegen = .06
        }
        if (type == 6) {
          this.manaRegen = .125
        }
        if (type == 7) {
          this.manaRegen = .111
        }
        if (type == 8) {
          this.manaRegen = .123
        }
        if (type == 9) {
          this.manaRegen = .1
        }
        if (type == 10) {
          this.manaRegen = .135
        }
        return this.manaRegen
      }
      speedMaker(type) {
        this.tempSpeed = 0
        this.speed = 1
        if (type == -1) {
          this.speed = 1.5
        }
        if (type == 0) {
          this.speed = 5
        }
        if (type == 1) {
          this.speed = 2
        }
        if (type == 2) {
          this.speed = 4
        }
        if (type == 3) {
          this.speed = 3
        }
        if (type == 4) {
          this.speed = 2.5
        }
        if (type == 5) {
          this.speed = 2.8 
        }
        if (type == 6) {
          this.speed = 4.2
        }
        if (type == 7) {
          this.speed = 3.7
        }
        if (type == 8) {
          this.speed = 4.6
        }
        if (type == 9) {
          this.speed = 2.9
        }
        if (type == 10) {
          this.speed = 5.5
        }
        return this.speed
      }
      bighealthDraw() {
        if (this.health < 0) {
          this.health = 0
        }
        if (this.health > this.maxhealth) {
          this.health = this.maxhealth
        }
        if (this.mana < 0) {
          this.mana = 0
        }
        if (this.mana > this.maxmana) {
          this.mana = this.maxmana
        }
        this.healthBar = new Rectangle(this.gear[0].box.x, this.gear[0].box.y - 13, 480 * (this.health / this.maxhealth), 13, "#00ff00")
        this.healthBarBack = new Rectangle(this.gear[0].box.x, this.gear[0].box.y - 13, 480, 13, "#000000")
        this.healthBarOut = new Rectangle(this.gear[0].box.x - 2, this.gear[0].box.y - 15, 484, 15, "#000000")
        this.healthBarOut.draw()
        this.healthBarBack.draw()
        if (this.team.top == 0) {
          this.healthBar.color = "#FF0000"
        } else {
          this.healthBar.color = "#00FF00"
        }
        this.healthBar.draw()
        canvas_context.strokeStyle = "white"
        canvas_context.lineWidth = 2.5
        canvas_context.fillStyle = "black"
        canvas_context.font = "13px comic sans ms"
        canvas_context.strokeText(Math.round(this.health) + "/" + this.maxhealth, this.healthBar.x + 210, this.healthBar.y + 12)
        canvas_context.fillText(Math.round(this.health) + "/" + this.maxhealth, this.healthBar.x + 210, this.healthBar.y + 12)
        if (this.type != -1) {

          this.manaBar = new Rectangle(this.gear[0].box.x, this.gear[0].box.y - 28, 480 * (this.mana / this.maxmana), 13, "#00ffff")
          this.manaBarBack = new Rectangle(this.gear[0].box.x, this.gear[0].box.y - 28, 480, 13, "#000000")
          this.manaBarOut = new Rectangle(this.gear[0].box.x - 2, this.gear[0].box.y - 30, 484, 15, "#000000")
          this.manaBarOut.draw()
          this.manaBarBack.draw()
          if (this.team.top == 0) {
            this.manaBar.color = "#0000ff"
          } else {
            this.manaBar.color = "#00FFFF"
          }
          this.manaBar.draw()
          let mb = Math.floor(this.maxmana / 100)
          let mbx = (this.maxmana / 100)
          for (let g = 1; g < mb; g++) {
            let x = (this.manaBar.x + ((480 / mb) * g)) - .25
            let rect = new Rectangle(x, this.manaBar.y, .5, 10, "black")
            rect.draw()
          }
          canvas_context.strokeStyle = "white"
          canvas_context.lineWidth = 2.5
          canvas_context.fillStyle = "black"
          canvas_context.font = "13px comic sans ms"
          canvas_context.strokeText(Math.round(this.mana) + "/" + this.maxmana, this.manaBar.x + 210, this.manaBar.y + 12)
          canvas_context.fillText(Math.round(this.mana) + "/" + this.maxmana, this.manaBar.x + 210, this.manaBar.y + 12)
        }
        let hb = Math.floor(this.maxhealth / 100)
        let hbx = (this.maxhealth / 100)
        for (let g = 1; g < hb; g++) {
          let x = (this.healthBar.x + ((480 / hb) * g)) - .25
          let rect = new Rectangle(x, this.healthBar.y, .5, 10, "black")
          rect.draw()
        }
        // //////////////////////////////////////////////////////////console.log(this)
      }
      healthDraw() {
        if (this.health < 0) {
          this.health = 0
        }
        if (this.health > this.maxhealth) {
          this.health = this.maxhealth
        }
        if (this.mana < 0) {
          this.mana = 0
        }
        if (this.mana > this.maxmana) {
          this.mana = this.maxmana
        }
        this.healthBar = new Rectangle(this.body.x - 32, this.body.y - 42, 64 * (this.health / this.maxhealth), 7, "#00ff00")
        this.healthBarBack = new Rectangle(this.body.x - 32, this.body.y - 42, 64, 7, "#000000")
        this.healthBarOut = new Rectangle(this.body.x - 34, this.body.y - 44, 68, 11, "#000000")
        this.healthBarOut.draw()
        this.healthBarBack.draw()
        if (this.team.top == 0) {
          this.healthBar.color = "#FF0000"
        } else {
          this.healthBar.color = "#00FF00"
        }
        this.healthBar.draw()
        if (this.type != -1) {

          this.manaBar = new Rectangle(this.body.x - 32, this.body.y - 50, 64 * (this.mana / this.maxmana), 7, "#00ffFF")
          this.manaBarBack = new Rectangle(this.body.x - 32, this.body.y - 50, 64, 7, "#000000")
          this.manaBarOut = new Rectangle(this.body.x - 34, this.body.y - 52, 68, 11, "#000000")
          this.manaBarOut.draw()
          this.manaBarBack.draw()

          if (this.team.top == 0) {
            this.manaBar.color = "#0000ff"
          } else {
            this.manaBar.color = "#00FFFF"
          }
          this.manaBar.draw()
          let mb = Math.floor(this.maxmana / 100)
          let mbx = (this.maxmana / 100)
          for (let g = 1; g < mb; g++) {
            let x = (this.manaBar.x + ((64 / mb) * g)) - .25
            let rect = new Rectangle(x, this.manaBar.y, .5, 7, "black")
            rect.draw()
          }
        }
        let hb = Math.floor(this.maxhealth / 100)
        let hbx = (this.maxhealth / 100)
        for (let g = 1; g < hb; g++) {
          let x = (this.healthBar.x + ((64 / hb) * g)) - .25
          let rect = new Rectangle(x, this.healthBar.y, .5, 7, "black")
          rect.draw()
        }
        // //////////////////////////////////////////////////////////console.log(this)
      }
      tick() {

        if (!champids.includes(this.id)) {
          champids[players.indexOf(this)] = this.id
        }
        for (let t = 0; t < this.gear.length; t++) {
          this.gear[t].reset()
        }
        for (let t = 0; t < this.gear.length; t++) {
          this.gear[t].balance()
        }
        if (this == players[0]) {
          ////////////////////////console.log(this)
        }
        this.health += this.healthRegen * this.gaerboosts.healthregen
        this.mana += this.manaRegen * this.gaerboosts.manaregen

        for (let t = 0; t < this.drops.length; t++) {
          if (this.drops[t].dirLock > 0) {
            this.drops[t].dirLock--
            if (this.drops[t].dirLock > 0) {
            } else {
              this.drops.splice(t, 1)
            }
          }
        }
        for (let t = 0; t < this.boosts.length; t++) {
          if (this.boosts[t].speedDown > 0) {
            this.boosts[t].speedDown--
            if (this.boosts[t].speedDown > 0) {
            } else {
              this.tempSpeed -= this.boosts[t].dropBy
              this.boosts.splice(t, 1)
            }
          }
        }
        this.rate++
        if (this.rate > this.chunk) {
          this.step++
          this.rate = 0
        }
        if (this.slimeToggle == 1) {
          if (this.type == 1) {
            this.dropSlime(this)
          }
          if (this.type == 4) {
            let link = new LineOP(this.body, TIP_engine)
            this.nhaigrape(this, this.body.x + (Math.cos(link.angle()) * 200), this.body.y + (Math.sin(link.angle()) * 200))
          }
        }
        this.cooldowns[0]--
        this.cooldowns[1]--
        this.cooldowns[2]--
        this.cooldowns[3]--
        this.cooldowns[4]--

      }
      fieldStuffA() {

        if (!this.activeArts) {
          this.activeArts = []
        }


        for (let t = 0; t < this.activeArts.length; t++) {
          if (this.activeArts[t]) { } else { continue }
          if (this.activeArts[t].moveAngle == 1 && this.activeArts[t].local == 1) {
            this.activeArts[t].angle = ((this.activeArts[t].angle * 10) + (new LineOP(this.last, this.body)).angle()) / 11
          }
          if (this.activeArts[t].root && this.activeArts[t].local == 1) {
            if (this.activeArts[t].name == "Circle") {
              if (this.activeArts[t].bodo == 1 && this.activeArts[t].local == 1) {
                this.activeArts[t].root = TIP_engine
              }
            }
            if (this.activeArts[t].name == "LineOP") {
              if (this.activeArts[t].bodo == 1 && this.activeArts[t].local == 1) {
                this.activeArts[t].target = new Point(TIP_engine.x, TIP_engine.y)
              }
            }
            this.activeArts[t].x = this.activeArts[t].root.x
            this.activeArts[t].y = this.activeArts[t].root.y
          }
          if (this.activeArts[t].maxDis >= 1) {
            let link = new LineOP(this.activeArts[t], this.body)
            if (link.hypotenuse() > this.activeArts[t].maxDis) {
              let lah = link.angle()
              this.activeArts[t].x = this.body.x + (Math.cos(lah) * this.activeArts[t].maxDis)
              this.activeArts[t].y = this.body.y + (Math.sin(lah) * this.activeArts[t].maxDis)
            } else {
              let haa = link.hypotenuse()
              let lah = link.angle()
              this.activeArts[t].x = this.body.x + (Math.cos(lah) * haa)
              this.activeArts[t].y = this.body.y + (Math.sin(lah) * haa)
            }
            if (this.activeArts[t].name == "LineOP") {
              let ah = this.activeArts[t].hypotenuse()
              let ha = this.activeArts[t].angle()
              this.activeArts[t].target.x = this.body.x + (Math.cos(ha) * Math.min(ah, this.activeArts[t].maxDis))
              this.activeArts[t].target.y = this.body.y + (Math.sin(ha) * Math.min(ah, this.activeArts[t].maxDis))
            }
            if (this.activeArts[t].radius > this.activeArts[t].maxDis) {
              this.activeArts[t].radius = this.activeArts[t].maxDis
            }
          }
        }
        for (let t = 0; t < this.activeArts.length; t++) {

          if (this.activeArts[t]) { } else { continue }


          if (this.activeArts[t].growth >= 0) {
            this.activeArts[t].radius *= this.activeArts[t].growth
          }
          if (this.activeArts[t].reverse == 1) {
            if (this.activeArts[t].life == 20) {
              this.activeArts[t].xmom *= -1
              this.activeArts[t].ymom *= -1
            }
          }

          this.activeArts[t].move()
          if (!(this.activeArts[t].id > 0)) {
            this.activeArts[t].id = Math.floor(Math.random() * 9000000)
          }
          if (this.activeArts[t].flagged != 1) {
            this.activeArts[t].draw()
          }

          if (this.team.top == players[0].team.top && (this.type == -1 || this == players[0])) {

            if (ws.readyState == 1 && this.activeArts[t].sent != 0) {
              if (this.send == 1) {
                let json = {}
                json.isA = this.activeArts[t].name
                json.champid = this.id
                json.index = t
                json.collider = 1
                let sto
                let stot
                let zum = 0
                let follow = 0
                let lum = this.activeArts[t].life
                // if (this.activeArts[t].root) {
                if (this.activeArts[t].tip == 1) {
                  zum = 1
                  lum = this.activeArts[t].life
                }
                if (this.activeArts[t].follow == 1) {
                  follow = 1
                  lum = this.activeArts[t].life
                  this.activeArts[t].life = 1
                }
                // if (this.activeArts[t].name == "TongueSpike") {
                //   follow = 1
                //   lum = this.activeArts[t].life
                //   this.activeArts[t].life = 1
                // }
                // }
                sto = this.activeArts[t].root
                stot = this.activeArts[t].track
                if (this.activeArts[t].root) {
                  this.activeArts[t].root = new Circle(this.activeArts[t].root.x, this.activeArts[t].root.y)
                }
                if (this.activeArts[t].track) {
                  this.activeArts[t].track = new Circle(this.activeArts[t].track.x, this.activeArts[t].track.y)
                }
                if (this.activeArts[t].root) {
                  if (this.activeArts[t].root.body) {
                    this.activeArts[t].root = new Circle(0, 0, 1, "red")
                    this.activeArts[t].root.body = new Circle(0, 0, 1, "red")
                    this.activeArts[t].rootflag = "self"
                    if (zum == 1) {
                      this.activeArts[t].rootflag = "tip"
                      this.activeArts[t].life = 1
                    }
                  }
                }
                if (this.activeArts[t].track) {
                  if (this.activeArts[t].track.body) {
                    this.activeArts[t].track = new Circle(0, 0, 1, "red")
                    this.activeArts[t].track.body = new Circle(0, 0, 1, "red")
                    this.activeArts[t].trackflag = "self"
                  }
                }
                if (this.activeArts[t].name == "LineOP") {
                  //////////////////////////////////console.log("f")
                  this.activeArts[t].object = new Circle(this.activeArts[t].object.x, this.activeArts[t].object.y)
                  this.activeArts[t].target = new Circle(this.activeArts[t].target.x, this.activeArts[t].target.y)
                }
                // if (this.activeArts[t].name == "TongueSpike") {
                //   this.activeArts[t].track = new Circle(this.activeArts[t].track.x, this.activeArts[t].track.y)
                //   this.activeArts[t].root = new Circle(this.activeArts[t].root.x, this.activeArts[t].root.y)
                //   this.activeArts[t].guy = {}
                // }
                if (this.activeArts[t].shield == 1) {
                  lum = this.activeArts[t].life
                  this.activeArts[t].life = 1
                }
                if (this.activeArts[t].anchorToPlayer == 1) {
                  lum = this.activeArts[t].life
                  this.activeArts[t].life = 1
                }
                if (this.activeArts[t].sendEveryFrame == 1) {
                  lum = this.activeArts[t].life
                  this.activeArts[t].life = 1
                }
                //////////console.log(this.activeArts[t])
                json.packet = JSON.stringify(this.activeArts[t])
                this.activeArts[t].life = lum

                if (this.activeArts[t].root) {
                  if (this.activeArts[t].root.body) {
                    this.activeArts[t].root.body = sto

                  }
                }
                this.activeArts[t].track = stot
                if (this.activeArts[t].tip == 1 && this.activeArts[t].local == 1) {
                  this.activeArts[t].track = TIP_engine
                  this.activeArts[t].x = TIP_engine.x
                  this.activeArts[t].y = TIP_engine.y
                }
                if (this.activeArts[t].bod == 1) {
                  this.activeArts[t].track = this.body
                  this.activeArts[t].root = this.body
                }
                json.aid = this.activeArts[t].id
                json.collide = this.activeArts[t].collide
                let l = new LineOP(TIP_engine, this.body)
                let a = l.angle()
                if ((this.type == 0 || this.type == 4 || this.type == 9) && this.activeArts[t].name == "Circle") {

                  let f = new Point(this.body.x - (Math.cos(a) * Math.max(-l.hypotenuse(), -this.activeArts[t].maxDis)), this.body.y - (Math.sin(a) * Math.max(-l.hypotenuse(), -this.activeArts[t].maxDis)))
                  json.mouse = JSON.stringify({ x: f.x, y: f.y })
                } else {

                  let f = new Point(this.body.x - (Math.cos(a) * Math.min(l.hypotenuse(), this.activeArts[t].maxDis)), this.body.y - (Math.sin(a) * Math.min(l.hypotenuse(), this.activeArts[t].maxDis)))
                  json.mouse = JSON.stringify({ x: f.x, y: f.y })
                }
                if (this.activeArts[t].solar == 1) {
                  json.solar = 1
                  json.guyIndex = this.activeArts[t].guyIndex
                  json.mouse = JSON.stringify({ x: TIP_engine.x, y: TIP_engine.y })
                }
                json.bod = JSON.stringify({ x: this.body.x, y: this.body.y })
                json.bodo = this.activeArts[t].bodo
                json.name = this.activeArts[t].name
                //////////////////////////////////console.log(json.bodo,this.activeArts[t] )
                //////////////////////////////////console.log(json.name,this.activeArts[t] )
                json.bodi = this.activeArts[t].bodi
                json.bodz = this.activeArts[t].bod
                json.bodid = this.activeArts[t].bodid
                json.artid = this.activeArts[t].id
                json.tip = this.activeArts[t].tip
                json.song = this.activeArts[t].song
                if (this.activeArts[t].shielded != 1) {
                  json.shield = this.activeArts[t].shield
                  this.activeArts[t].shielded = 1
                }
                // this.activeArts[t].life++ 
                // ////////console.log(json)
                logBinarySize(JSON.stringify(json))
                ws.send(JSON.stringify(json))
                // this.activeArts[t].life--
                // if (this.activeArts[t].name == "TongueSpike") {
                //   this.activeArts[t].track = this.body
                //   this.activeArts[t].guy = this
                // }
                if (this.activeArts[t].name == "LineOP") {
                  this.activeArts[t].object = this.body
                  this.activeArts[t].target = TIP_engine
                }
                this.activeArts[t].sent = 0
                // if (this.activeArts[t].name == "TongueSpike") {
                //   this.activeArts[t].sent = 1
                // }
                if (zum == 1) {
                  this.activeArts[t].sent = 1
                }
                if (follow == 1) {
                  this.activeArts[t].sent = 1
                }
                if (this.activeArts[t].shield == 1) {
                  this.activeArts[t].sent = 1
                }
                if (this.activeArts[t].anchorToPlayer == 1) {
                  this.activeArts[t].sent = 1
                }

                if (this.activeArts[t].sendEveryFrame == 1) {
                  this.activeArts[t].sent = 1
                }
              }
            }

          }
          this.activeArts[t].life--
        }
      }

      fieldStuffB() {

        if (!this.activeArts) {
          this.activeArts = []
        }
        for (let t = this.activeArts.length - 1; t >= 0; t--) {

          if (this.activeArts[t]) { } else { continue }
          if (this.activeArts[t].life <= 0) {
            // //////////////////////console.log(this.activeArts[t])
            this.activeArts.splice(t, 1)
          }
        }
      }
      reward(enemy) {
        if (this.rewardCap != 1) {
          this.rewardCap = 1
          if (this.type == -1) {
            let json = {}
            json.rewardid = enemy.id
            json.splicid = this.id
            json.x = Math.round(this.body.x)
            json.y = Math.round(this.body.y)
            json.reward = 50 + Math.floor(Math.random() * 11)
            if (this.send == 1) {
              logBinarySize(JSON.stringify(json))
              ws.send(JSON.stringify(json))
            }
            return 50 + Math.floor(Math.random() * 11)
          } else {
            if (this.goldtotal > 0) {
              let json = {}
              json.rewardid = enemy.id
              json.splicid = this.id
              json.x = Math.round(this.body.x)
              json.y = Math.round(this.body.y)
              json.reward = 100 + Math.floor(Math.random() * 11) + Math.floor(this.goldtotal / 60)
              if (this.send == 1) {
                logBinarySize(JSON.stringify(json))
                ws.send(JSON.stringify(json))
              }
              return 100 + Math.floor(Math.random() * 11) + Math.floor(this.goldtotal / 60)
            } else {
              let json = {}
              json.reward = 100
              json.x = Math.round(this.body.x)
              json.y = Math.round(this.body.y)
              json.rewardid = enemy.id
              json.splicid = this.id
              if (this.send == 1) {
                logBinarySize(JSON.stringify(json))
                ws.send(JSON.stringify(json))
              }
              return 100
            }
          }
        }

        return 0
      }
      drawUI() {
        this.UI = [new Rectangle(240, 660, 60, 60, "#880000"), new Rectangle(300, 660, 60, 60, "#880000"), new Rectangle(360, 660, 60, 60, "#880000"), new Rectangle(420, 660, 60, 60, "#880000")]

        canvas_context.fillStyle = "gold"
        canvas_context.font = "30px comic sans ms"
        canvas_context.fillText(this.gold, 20 - translator.x, 40 - translator.y)


        for (let t = 0; t < this.gear.length; t++) {
          if (this.gear[t] > -100) {

            this.gear[t] = new Gear(this.gear[t], this, t)
          }
          this.gear[t].draw()
        }
        for (let t = 0; t < this.UI.length; t++) {
          this.UI[t].x -= translator.x
          this.UI[t].y -= translator.y
          this.UI[t].draw()
        }
        if (this.type == 0) {
          canvas_context.drawImage(psycons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 1) {
          canvas_context.drawImage(slugcons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 2) {
          canvas_context.drawImage(pomcons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 3) {
          canvas_context.drawImage(miscons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 4) {
          canvas_context.drawImage(nhaicons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 5) {
          canvas_context.drawImage(suncons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 6) {
          canvas_context.drawImage(banicons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 7) {
          canvas_context.drawImage(xlicons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 8) {
          canvas_context.drawImage(mantcons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 9) {
          canvas_context.drawImage(hamcons, this.UI[0].x, this.UI[0].y)
        } else if (this.type == 10) {
          canvas_context.drawImage(jetcons, this.UI[0].x, this.UI[0].y)
        }

        for (let t = 0; t < this.UI.length; t++) {
          if (this.cooldowns[t] > 0) {
            this.UI[t].color = "#FFFFFF99"
            this.UI[t].draw()
            canvas_context.fillStyle = "black"
            canvas_context.font = "20px comic sans ms"
            canvas_context.fillText((1 + Math.floor(this.cooldowns[t] / 30)), this.UI[t].x + 7, this.UI[t].y + 30)
          }
        }
      }
      move() {
        this.last = new Point(this.body.x, this.body.y)
        if (this.sleep == 1) {

          if (ws.readyState == 1) { //can send
            if (this.team.top == players[0].team.top && this.send == 1) { //somehow only send the players team
              let json = {} //new message
              if (this.type == -1) { //minion
                json.minion = 1 //flag minion 
                json.health = Math.round(this.health) //carry health for UI
                json.skin = Math.round(this.skin) //carry health for UI
                json.x = Math.round(this.body.x) //positional x
                json.y = Math.round(this.body.y) //positional y
                json.shield = this.shield //positional y
                json.id = this.id //id for lookup hits
                json.slowedByFloor = this.slowedByFloor
                json.top = this.team.top //id for lookup hits
                if (time % 2 != 0 || true) {
                  logBinarySize(JSON.stringify(json))
                  ws.send(JSON.stringify(json)) //send object to other players
                }
              } else {
                json.champ = 1 //flag for character
                json.team = (this.team.top - 1) * -1//somehow only send the players team
                let k = [...this.team.players]//decircularize team
                let g = [...this.gear]//decircularize gear
                let a = [...this.activeArts]//decircularize colliders
                this.activeArts = []//remove collider
                let t = this.team//decircularize team
                this.gear = [this.gear[0].type, this.gear[1].type, this.gear[2].type, this.gear[3].type]//fake gear data for resistances etc
                json.gear = [this.gear[0], this.gear[1], this.gear[2], this.gear[3]]//pack gear data
                json.slowedByFloor = this.slowedByFloor
                json.top = this.team.top
                if (this.sleep > -1) {
                  json.sleep = this.sleep
                }
                json.packet = JSON.stringify(this) // pack message
                let packetz = JSON.parse(json.packet) // pack message

                delete packetz.UI
                delete packetz.healthBar
                delete packetz.healthBarBack
                delete packetz.healthBarOut
                delete packetz.manaBar
                delete packetz.manaBarBack
                delete packetz.manaBarOut
                delete packetz.gaerboosts
                delete packetz.cooldowns
                delete packetz.abilities
                delete packetz.selected
                delete packetz.hitlane
                delete packetz.smackline
                delete packetz.zop
                delete packetz.tar
                delete packetz.send
                delete packetz.healthbar
                delete packetz.tar
                delete packetz.tar
                delete packetz.tar
                delete packetz.sleep
                delete packetz.rate
                delete packetz.chunk
                delete packetz.tempSpeed
                delete packetz.tempMeleeRange
                delete packetz.tempManaRegen
                delete packetz.tempHealthRegen
                delete packetz.speed
                delete packetz.meleeRange
                delete packetz.manaRegen
                delete packetz.healthRegen
                delete packetz.slimeToggle
                delete packetz.local
                delete packetz.maxHealth
                delete packetz.drops
                delete packetz.boosts
                delete packetz.step
                delete packetz.tempHealth
                delete packetz.team
                delete packetz.body
                delete packetz.activeArts
                delete packetz.slowedByFloor
                delete packetz.last
                delete packetz.slimeTime
                packetz.health = Math.round(packetz.health)
                packetz.mana = Math.round(packetz.mana)
                packetz.body = {}
                packetz.body.x = Math.round(this.body.x)
                packetz.body.y = Math.round(this.body.y)
                packetz.body.radius = this.body.radius
                let b = new Point(this.body.x, this.body.y)
                let gm = new Point(this.goal.x, this.goal.y)
                b.radius = this.body.radius
                packetz.body = b
                packetz.goal = gm
                json.packet = JSON.stringify(packetz)
                ////////////////console.log(JSON.parse(json.packet), packetz)

                this.team.players = [...k] // recyclize team
                this.team = t// recyclize team
                this.activeArts = [...a]// recyclize colliders
                this.gear = [new Gear(this.gear[0], this, 0), new Gear(this.gear[1], this, 1), new Gear(this.gear[2], this, 2), new Gear(this.gear[3], this, 3)]//reconstruct and recyclize gear
                json.id = this.id//id for lookup hits
                if (time % 2 != 0 || true) {
                  ////console.log("huh")
                  logBinarySize(JSON.stringify(json))
                  ws.send(JSON.stringify(json)) //send object to other players
                }
              }
            }
          }

          return
        }
        if (this.type == -1) {
          // this.goal = this.body
          let target = {}
          let min = 99999999
          let wet = 0
          ////////////console.log(this.tar, zones)




          for (let t = 0; t < players.length; t++) {
            if (players[t]) { } else { continue }
            if (players[t].team.top != this.team.top) {
              let link = new LineOP(this.body, players[t].body)
              let h = link.hypotenuse()
              if (h < min && h < 400) {
                min = h
                target = players[t]
                wet = 1
              }
            }
          }
          if (wet == 1) {
            this.goal = target.body
          } else {



            if (this.hitlane == 0) {
              let link = new LineOP(this.body, zones[this.tar])
              let h = link.hypotenuse()
              if (h < min && h > 50 && this.hitlane == 0) {
                min = h
                target = zones[this.tar]
                ////////////console.log(this.tar)
                wet = 1
                ////////////console.log(wet)
              }
            }
            if (this.body.doesPerimeterTouch(zones[this.tar])) {
              this.smackline++
              if (this.smackline == 3) {
                this.hitlane = 1
              }
              if (this.smackline == 1) {
                if (this.tar == 0) {
                  this.tar = 3
                } else if (this.tar == 1) {
                  this.tar = 4
                } else if (this.tar == 2) {
                  this.tar = 5
                } else if (this.tar == 6) {
                  this.tar = 3
                } else if (this.tar == 7) {
                  this.tar = 4
                } else if (this.tar == 8) {
                  this.tar = 5
                }
              }
              if (this.smackline == 2) {
                if (this.zop == 1) {
                  if (this.tar == 3) {
                    this.tar = 0
                  } else if (this.tar == 4) {
                    this.tar = 1
                  } else if (this.tar == 5) {
                    this.tar = 2
                  }
                } else {
                  if (this.tar == 3) {
                    this.tar = 6
                  } else if (this.tar == 4) {
                    this.tar = 7
                  } else if (this.tar == 5) {
                    this.tar = 8
                  }
                }
              }

            }
            if (wet == 1) {
              this.goal = target
              ////////////console.log(this.goal)
            } else {


              for (let t = 0; t < players.length; t++) {
                if (players[t]) { } else { continue }
                if (players[t].team.top != this.team.top) {
                  let link = new LineOP(this.body, players[t].body)
                  let h = link.hypotenuse()
                  if (h < min && h < 500) {
                    min = h
                    target = players[t]
                    wet = 1
                  }
                }
              }
              if (wet == 1) {
                this.goal = target.body
              } else {
                for (let t = 0; t < players.length; t++) {
                  if (players[t]) { } else { continue }
                  if (players[t].type != -1 && players[t].team.top != this.team.top) {
                    let link = new LineOP(this.body, players[t].body)
                    let h = link.hypotenuse()
                    if (h < min && h < 500) {
                      min = h
                      target = players[t]
                      wet = 1
                    }
                  }
                }

                for (let t = 0; t < teams.length; t++) {
                  if (teams[t].top != this.team.top) {
                    let link = new LineOP(this.body, teams[t].body)
                    let h = link.hypotenuse()
                    if (h < min) {
                      min = h
                      target = teams[t]
                      wet = 1
                    }
                  }
                }
                if (wet == 1) {
                  this.goal = target.body
                }
                if (wet == 1) {
                  this.goal = target.body
                } else {

                }
              }
            }

          }
        }
        if (this.rooted > 0) {
          this.rooted--
          let xdiff = this.body.x - this.root.x
          let ydiff = this.body.y - this.root.y
          if (this == players[0]) {

            //canvas_context.translate(xdiff, ydiff)
            //translator.x += xdiff
            //translator.y += ydiff
          }
          this.body.x = this.root.x
          this.body.y = this.root.y

          if (this.goto) {
            let l = new LineOP(this.goto, this.root)
            let a = l.angle()
            let h = l.hypotenuse()
            this.root.x = this.goto.x - (Math.cos(a) * h * .85)
            this.root.y = this.goto.y - (Math.sin(a) * h * .85)
          }
          this.goal = this.root
        } else if (this.goal) {
          if (this.goal == this.body) {

          } else {
            if (Math.abs(this.goal.x - this.body.x) + Math.abs(this.goal.y - this.body.y) > 2) {
              for (let t = 0; t < ((((this.speed + this.tempSpeed) * 2) * this.slowedByFloor) * this.gaerboosts.speed); t++) {
                let as = (new LineOP(this.goal, this.body)).angle()
                if (this.type == -1) {

                  this.body.x += Math.sign(this.goal.x - this.body.x) * .5 + ((Math.cos(as) / 2))
                  this.body.y += Math.sign(this.goal.y - this.body.y) * .5 + ((Math.sin(as) / 2))
                } else {
                  this.body.x += Math.sign(this.goal.x - this.body.x) * .0 + ((Math.cos(as) / 1))
                  this.body.y += Math.sign(this.goal.y - this.body.y) * .0 + ((Math.sin(as) / 1))
                }
                if (this.selected == 1 && players.indexOf(this) == 0) {
                  // let as = (new LineOP(this.goal, this.body)).angle()
                  //canvas_context.translate(-((Math.sign(this.goal.x - this.body.x) * .5) + Math.cos(as) / 2), -((Math.sign(this.goal.y - this.body.y) * .5) + Math.sin(as) / 2))

                  //translator.x -= (Math.sign(this.goal.x - this.body.x) * .5) + ((Math.cos(as) / 2))
                  //translator.y -= (Math.sign(this.goal.y - this.body.y) * .5) + ((Math.sin(as) / 2))
                }
              }
            } else {
              for (let t = 0; t < this.drops.length; t++) {
                if (this.drops[t].dirLock > 0) {
                  this.drops.splice(t, 1)
                }
              }
            }
          }
          if (this.send == 1) {
            this.slowedByFloor = 1
          }
        }

        if (ws.readyState == 1) { //can send
          if (this.team.top == players[0].team.top && this.send == 1) { //somehow only send the players team
            let json = {} //new message
            if (this.type == -1) { //minion
              json.minion = 1 //flag minion 
              json.skin = Math.round(this.skin) //carry health for UI
              json.health = Math.round(this.health) //carry health for UI
              json.x = Math.round(this.body.x) //positional x
              json.y = Math.round(this.body.y) //positional y
              json.shield = this.shield //positional y
              json.id = this.id //id for lookup hits
              json.top = this.team.top //id for lookup hits
              json.slowedByFloor = this.slowedByFloor
              if (time % 2 != 0 || true) {
                logBinarySize(JSON.stringify(json))
                ws.send(JSON.stringify(json)) //send object to other players
              }
            } else {
              json.champ = 1 //flag for character
              json.team = (this.team.top - 1) * -1//somehow only send the players team
              let k = [...this.team.players]//decircularize team
              let g = [...this.gear]//decircularize gear
              let a = [...this.activeArts]//decircularize colliders
              this.activeArts = []//remove collider
              let t = this.team//decircularize team
              this.gear = [this.gear[0].type, this.gear[1].type, this.gear[2].type, this.gear[3].type]//fake gear data for resistances etc
              json.gear = [this.gear[0], this.gear[1], this.gear[2], this.gear[3]]//pack gear data
              json.top = this.team.top
              if (this.sleep > -1) {
                json.sleep = this.sleep
              }
              json.packet = JSON.stringify(this) // pack message
              let packetz = JSON.parse(json.packet) // pack message

              delete packetz.UI
              delete packetz.healthBar
              delete packetz.healthBarBack
              delete packetz.healthBarOut
              delete packetz.manaBar
              delete packetz.manaBarBack
              delete packetz.manaBarOut
              delete packetz.gaerboosts
              delete packetz.cooldowns
              delete packetz.abilities
              delete packetz.selected
              delete packetz.hitlane
              delete packetz.smackline
              delete packetz.zop
              delete packetz.tar
              delete packetz.send
              delete packetz.healthbar
              delete packetz.tar
              delete packetz.tar
              delete packetz.tar
              delete packetz.sleep
              delete packetz.rate
              delete packetz.chunk
              delete packetz.tempSpeed
              delete packetz.tempMeleeRange
              delete packetz.tempManaRegen
              delete packetz.tempHealthRegen
              delete packetz.speed
              delete packetz.meleeRange
              delete packetz.manaRegen
              delete packetz.healthRegen
              delete packetz.slimeToggle
              delete packetz.local
              delete packetz.maxHealth
              delete packetz.drops
              delete packetz.boosts
              delete packetz.step
              delete packetz.tempHealth
              delete packetz.team
              delete packetz.body
              delete packetz.activeArts
              delete packetz.slowedByFloor
              delete packetz.last
              delete packetz.slimeTime
              packetz.health = Math.round(packetz.health)
              packetz.mana = Math.round(packetz.mana)
              packetz.body = {}
              packetz.body.x = Math.round(this.body.x)
              packetz.body.y = Math.round(this.body.y)
              packetz.body.radius = this.body.radius
              let b = new Point(this.body.x, this.body.y)
              let gm = new Point(this.goal.x, this.goal.y)
              b.radius = this.body.radius
              packetz.body = b
              packetz.goal = gm
              json.packet = JSON.stringify(packetz)
              ////////////////console.log(JSON.parse(json.packet), packetz)
              this.team.players = [...k] // recyclize team
              this.team = t// recyclize team
              this.activeArts = [...a]// recyclize colliders
              this.gear = [new Gear(this.gear[0], this, 0), new Gear(this.gear[1], this, 1), new Gear(this.gear[2], this, 2), new Gear(this.gear[3], this, 3)]//reconstruct and recyclize gear
              json.id = this.id//id for lookup hits
              json.slowedByFloor = this.slowedByFloor
              if (time % 2 != 0 || true) {
                logBinarySize(JSON.stringify(json))
                ws.send(JSON.stringify(json)) //send object to other players
              }
            }
          }
        }


      }
      sing() {


        for (let t = this.activeArts.length - 1; t >= 0; t--) {
          if (this.activeArts[t].song && this.activeArts[t].played != 1) {
            this.activeArts[t].played = 1
            if(songs.length < 40){
            let aud = new Audio()
            aud.src = `https://ditzbitz.com/` + this.activeArts[t].song
            let packaud = {}
            packaud.song = aud
            packaud.id = this.id
            packaud.go = 0
            packaud.point = new Point(this.x, this.y)
            songs.push(packaud)
            }
          }
        }
      }
      collide(player) {
        if (player.id == this.id) {
          return
        }
        if (!player) {
          return
        }
        if (!player.activeArts) {
          player.activeArts = []
        }
        let j = 0
        let li = new LineOP(this.body, player.body)
        while (this.body.doesPerimeterTouch(player.body)) {
          j++
          if (j > 20) {
            break
          }
          let la = li.angle()
          this.body.x += Math.cos(la) * 5
          this.body.y += Math.sin(la) * 5
          player.body.x -= Math.cos(la) * 5
          player.body.y -= Math.sin(la) * 5
          if (player.body == players[0].body) {

            //canvas_context.translate(Math.cos(la), Math.sin(la))
            //translator.x += Math.cos(la)
            //translator.y += Math.sin(la)
          }
          if (this.body == players[0].body) {

            //canvas_context.translate(-Math.cos(la), -Math.sin(la))
            //translator.x -= Math.cos(la)
            //translator.y -= Math.sin(la)
          }

        }
        // if (player.team.top == this.team.top) {
        //   return
        // }
        for (let t = player.activeArts.length - 1; t >= 0; t--) {
          if (player.activeArts[t]) { } else { continue }
          if (player.team.top != this.team.top || player.activeArts[t].damage <= 0) { } else { continue }
          if (player.activeArts[t].doesPerimeterTouch) {
            //////////////////////////////////////console.log(player.activeArts[t], this)
            if (player.activeArts[t].doesPerimeterTouch(this.body)) {
              if (this.shield == 1) {
                this.shield = 0
                for (let k = this.activeArts.length - 1; k >= 0; k--) {
                  if (this.activeArts[k]) { } else { continue }
                  if (this.activeArts[k].knockShield == 1) {
                    this.activeArts.splice(k, 1)
                    continue
                  }
                }
                if (player.activeArts[t].collide == 1) {
                  let json = {}
                  json.spliceflag = 1
                  json.objectid = player.activeArts[t].id
                  json.playerid = player.id
                  logBinarySize(JSON.stringify(json))
                  ws.send(JSON.stringify(json))
                  player.activeArts.splice(t, 1)
                  continue
                }
                if (player.activeArts[t].grab == 1) {
                  player.activeArts[t].maxDis = player.activeArts[t].radius - 1
                  player.activeArts[t].grab = 0
                }

                continue
              }
              if (player.activeArts[t].line == 1) {
              }
              if (player.activeArts[t].grab == 1) {
                player.activeArts[t].grab = 0
                player.mana += player.maxmana / 8
                this.rooted = 10
                this.root = player.activeArts[t].k
                this.goto = player.body
                player.activeArts[t].maxDis = player.activeArts[t].radius - 1
              }
              if (player.activeArts[t].slow <= 1) {
                this.slowedByFloor *= player.activeArts[t].slow
              }
              if (this.team.top != player.team.top) {
                if (this.send == 1) {
                  if (((player.activeArts[t].damage * player.gaerboosts.damage) / this.gaerboosts.armor) > 0) {
                    this.health -= (player.activeArts[t].damage * player.gaerboosts.damage) / this.gaerboosts.armor
                  } else if (player.activeArts[t].healshock == 1) {
                    this.health += (player.activeArts[t].damage * player.gaerboosts.damage) / this.gaerboosts.armor
                  }
                }
                if (this.health <= 0) {
                  let pop = new DeathPop(this.body.x, this.body.y, '')
                  worldpops.push(pop)
                }
              } else {
                if (this.send == 1) {
                  if ((player.activeArts[t].damage * player.gaerboosts.damage) <= 0) {
                    this.health -= (player.activeArts[t].damage * player.gaerboosts.damage)
                  }
                }
              }

              if (this.health <= 0) {
                player.gold += this.reward(player)
                player.goldtotal += this.reward(player)
              }

              if (player.activeArts[t].emptyOut == 1) {
                player.activeArts[t].damage = 0
              }
              if (player.activeArts[t].collide == 1) {


                let json = {}
                json.spliceflag = 1
                json.objectid = player.activeArts[t].id
                json.x = player.activeArts[t].x
                json.y = player.activeArts[t].y
                json.pop = player.activeArts[t].pop
                json.playerid = player.id
                logBinarySize(JSON.stringify(json))
                ws.send(JSON.stringify(json))
                player.activeArts.splice(t, 1)
                continue
              }
            }
          }
        }
      }

      fakecollide(player) {
        if (player.id == this.id) {
          return
        }
        if (!player) {
          return
        }
        if (!player.activeArts) {
          player.activeArts = []
        }
        let j = 0
        let li = new LineOP(this.body, player.body)
        while (this.body.doesPerimeterTouch(player.body)) {
          j++
          if (j > 20) {
            break
          }
          let la = li.angle()
          this.body.x += Math.cos(la) * 5
          this.body.y += Math.sin(la) * 5
          player.body.x -= Math.cos(la) * 5
          player.body.y -= Math.sin(la) * 5

        }
        // if (player.team.top == this.team.top) {
        //   return
        // }
        for (let t = player.activeArts.length - 1; t >= 0; t--) {
          if (player.activeArts[t]) { } else { continue }
          if (player.team.top != this.team.top || player.activeArts[t].damage <= 0) { } else { continue }
          if (player.activeArts[t].doesPerimeterTouch) {
            //////////////////////////////////////console.log(player.activeArts[t], this)
            if (player.activeArts[t].doesPerimeterTouch(this.body)) {
              if (this.shield == 1) {
                this.shield = 0
                for (let k = this.activeArts.length - 1; k >= 0; k--) {
                  if (this.activeArts[k]) { } else { continue }
                  if (this.activeArts[k].knockShield == 1) {
                    // this.activeArts.splice(k, 1)
                    continue
                  }
                }
                if (player.activeArts[t].collide == 1) {
                  player.activeArts[t].flagged = 1
                  // player.activeArts[t].color = "transparent"
                  // let json = {}
                  // json.spliceflag = 1
                  // json.objectid = player.activeArts[t].id
                  // json.playerid = player.id
                  // logBinarySize(JSON.stringify(json))
                  // ws.send(JSON.stringify(json))
                  //   player.activeArts.splice(t, 1)
                  continue
                }
                if (player.activeArts[t].grab == 1) {
                  // player.activeArts[t].maxDis = player.activeArts[t].radius - 1
                  // player.activeArts[t].grab = 0
                }

                continue
              }
              if (player.activeArts[t].line == 1) {
              }
              if (player.activeArts[t].grab == 1) {
                // player.activeArts[t].grab = 0
                // player.mana += player.maxmana / 8
                // this.rooted = 10
                // this.root = player.activeArts[t].k
                // this.goto = player.body
                // player.activeArts[t].maxDis = player.activeArts[t].radius - 1
              }
              if (player.activeArts[t].slow <= 1) {
                this.slowedByFloor *= player.activeArts[t].slow
              }
              if (this.team.top != player.team.top) {
                if (this.send == 1) {
                  if (((player.activeArts[t].damage * player.gaerboosts.damage) / this.gaerboosts.armor) > 0) {
                    // this.health -= (player.activeArts[t].damage * player.gaerboosts.damage) / this.gaerboosts.armor
                  } else if (player.activeArts[t].healshock == 1) {
                    // this.health += (player.activeArts[t].damage * player.gaerboosts.damage) / this.gaerboosts.armor
                  }
                }
                if (this.health <= 0) {
                  // let pop = new DeathPop(this.body.x, this.body.y, '')
                  // worldpops.push(pop)
                }
              } else {
                if (this.send == 1) {
                  if ((player.activeArts[t].damage * player.gaerboosts.damage) <= 0) {
                    // this.health -= (player.activeArts[t].damage * player.gaerboosts.damage)
                  }
                }
              }

              if (this.health <= 0) {
                // player.gold += this.reward(player)
                // player.goldtotal += this.reward(player)
              }

              if (player.activeArts[t].emptyOut == 1) {
                // player.activeArts[t].damage = 0
              }
              if (player.activeArts[t].collide == 1) {
                player.activeArts[t].flagged = 1

                if (player.activeArts[t].pop == 1) {
                  // let angle = 0
                  // for (let p = 0; p < player.activeArts[t].poprays; p++) {
                  //   let ojb = new Circle(player.activeArts[t].x, player.activeArts[t].y, player.activeArts[t].popradius, player.activeArts[t].popcolor, Math.cos(angle) * player.activeArts[t].poprate, Math.sin(angle) * player.activeArts[t].poprate)
                  //   ojb.life = player.activeArts[t].poplife
                  //   ojb.damage = player.activeArts[t].popdam
                  //   ojb.collide = 1
                  //   ojb.id = player.activeArts[t].id + 1 + p

                  //   angle += (Math.PI * 2) / player.activeArts[t].poprays
                  //   ojb.name = "Circle"
                  //   player.activeArts.push(ojb)
                  // }
                }

                // let json = {}
                // json.spliceflag = 1
                // json.objectid = player.activeArts[t].id
                // json.playerid = player.id
                // logBinarySize(JSON.stringify(json))
                // ws.send(JSON.stringify(json))
                // player.activeArts.splice(t, 1)
                continue
              }
            }
          }
        }
      }
      draw() {


        // this.body.draw()
        // this.tick()
        // if(this.selected == 1){
        //     this.command()
        // }
        // this.fieldStuff()
        // this.artDraw()
        // if(this.selected == 1){
        // this.drawUI()
        // }
        // this.move()
      }
      meleehit() {
        if (this.type == -1) {
          let target = {}
          let min = 99999999
          let wet = 0
          for (let t = 0; t < players.length; t++) {
            if (players[t]) { } else { continue }
            if (players[t].team.top != this.team.top) {
              let link = new LineOP(this.body, players[t].body)
              let h = link.hypotenuse()
              if (h < min && h < 70) {
                min = h
                target = players[t]
                wet = 1
              }
            }
          }
          if (wet == 1) {
            this.abilities[0](this, target)
          } else {

            for (let t = 0; t < players.length; t++) {
              if (players[t]) { } else { continue }
              if (players[t].type != -1 && players[t].team.top != this.team.top) {
                let link = new LineOP(this.body, players[t].body)
                let h = link.hypotenuse()
                if (h < min && h < 70) {
                  min = h
                  target = players[t]
                  wet = 1
                }
              }
            }
            if (wet == 1) {
              this.abilities[0](this, target)
            } else {

              for (let t = 0; t < teams.length; t++) {
                if (teams[t].top != this.team.top) {
                  let link = new LineOP(this.body, teams[t].body)
                  let h = link.hypotenuse()
                  if (h < min && h < 70) {
                    min = h
                    target = teams[t]
                    wet = 1
                  }
                }
              }
              if (wet == 1) {
                this.abilities[0](this, target)
                if (teams.includes(target)) {
                  if (this.send == 1) {
                    let json = {}
                    json.smackupbase = teams.indexOf(target)
                    json.dam = 10
                    json.affiliation = this.team.top
                    if (json.smackupbase == 0) {
                      ////////////////console.log("t")
                    } else {
                      ////////////////console.log("r")
                      target.health -= 10
                      logBinarySize(JSON.stringify(json))
                      ws.send(JSON.stringify(json))

                      if (target.health <= 0) {
                        worldstop = 1
                        youLost = 0
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      meleehitChamp() {
        if (this.type != -1) {
          let target = {}
          let min = 99999999
          let wet = 0
          for (let t = 0; t < players.length; t++) {
            if (this != players[t]) { } else { continue }
            if (players[t]) { } else { continue }
            if (players[t].type != -1 && players[t].team.top != this.team.top) {
              let link = new LineOP(this.body, players[t].body)
              let h = link.hypotenuse()
              if (h < min && h < this.meleeRange) {
                min = h
                target = players[t]
                wet = 1
              }
            }
          }
          if (wet == 1) {
            this.basicAttack(this, target)
          } else {

            for (let t = 0; t < players.length; t++) {
              if (players[t]) { } else { continue }
              if (players[t].type == -1 && players[t].team.top != this.team.top) {
                let link = new LineOP(this.body, players[t].body)
                let h = link.hypotenuse()
                if (h < min && h < this.meleeRange) {
                  min = h
                  target = players[t]
                  wet = 1
                }
              }
            }
            if (wet == 1) {
              this.basicAttack(this, target)
            }
          }
        }
      }
      unitAI() {
        if (this.type == -1) {
          if (this.cooldowns[0] <= 0 && this.team.top == players[0].team.top) {
            this.meleehit()
          }
        }
      }
      champBasic() {
        if (this.type != -1) {
          if (this.cooldowns[4] <= 0) {
            if (this.team.top == players[0].team.top && this.send == 1) {
              this.meleehitChamp()
            }
          }
        }
      }
      champBasicAbility(self, x, y) { //jettian
        let target = new Circle(x, y, 32)

        let l = new LineOP(self.body, target.body)
        // if (l.hypotenuse() < (self.meleeRange * 1.15)) {
        self.cooldowns[3] = 30 * 1
        let manaCost = 0
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 6
        let d = new MeleeSpike(players.indexOf(self), self.meleeRange, (new LineOP(self.body, new Point(target.x, target.y)).angle()), "gray")
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.growth = 1
        d.growth = 1.3
        d.root = self.body
        d.maxDis = self.meleeRange
        d.damage = 80
        // d.collide = 1
        d.emptyOut = 1
        d.update = 1
        d.name = "MeleeSpike"
        self.activeArts.push(d)
        // }

      }
      command() {
        if (this.type == -1) {
          this.unitAI()
        } else {
          this.champBasic()
        }
        if ((keysPressed['q'] || this.qflag == 1) && this.cooldowns[0] <= 0) {
          this.qflag = 0
          if (this.type == 0) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -300), this.body.y + (Math.sin(link.angle()) * -300))
          }
          if (this.type == 1) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -180), this.body.y + (Math.sin(link.angle()) * -180))
          }
          if (this.type == 2) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * 180), this.body.y + (Math.sin(link.angle()) * 180))
          }
          if (this.type == 3) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * 180), this.body.y + (Math.sin(link.angle()) * 180))
          }
          if (this.type == 4) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -300), this.body.y + (Math.sin(link.angle()) * -300))
          }
          if (this.type == 5) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -300), this.body.y + (Math.sin(link.angle()) * -300))
          }
          if (this.type == 6) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -300), this.body.y + (Math.sin(link.angle()) * -300))
          }
          if (this.type == 7) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 8) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 9) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 10) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[0](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
        }
        if ((keysPressed['w'] || this.wflag == 1) && this.cooldowns[1] <= 0) {
          this.wflag = 0
          if (this.type == 0) {
            this.abilities[1](this, this.body.x, this.body.y)
          }
          if (this.type == 1) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 2) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 3) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 4) {
            this.abilities[1](this)
          }
          if (this.type == 5) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 6) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 7) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 8) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 9) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 10) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[1](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
        }
        if ((keysPressed['e'] || this.eflag == 1) && this.cooldowns[2] <= 0) {
          this.eflag = 0
          if (this.type == 0) {
            this.abilities[2](this)
          }
          if (this.type == 1) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this)
          }
          if (this.type == 2) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this)
          }
          if (this.type == 3) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 4) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 5) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 6) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 7) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 8) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 9) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 10) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[2](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
        }
        if ((keysPressed['r'] || this.rflag == 1) && this.cooldowns[3] <= 0) {
          this.rflag = 0
          if (this.type == 0) {
            this.abilities[3](this)
          }
          if (this.type == 1) {
            this.abilities[3](this)
          }
          if (this.type == 2) {
            this.abilities[3](this, this.body.x, this.body.y)
          }
          if (this.type == 3) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 4) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 5) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 6) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -100), this.body.y + (Math.sin(link.angle()) * -100))
          }
          if (this.type == 7) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 8) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 9) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
          if (this.type == 10) {
            let link = new LineOP(this.body, TIP_engine)
            this.abilities[3](this, this.body.x + (Math.cos(link.angle()) * -200), this.body.y + (Math.sin(link.angle()) * -200))
          }
        }
      }
      artDraw() {
        if (this.type == -1) {
          this.body.radius = 20
        } else {
          this.body.radius = 32
        }

        if (this.type == -1) {
          if (this.skin != 2) {

            if (this.team.top == 1) {
              canvas_context.drawImage(ie1, ((this.step % (ie1.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
            } else {
              canvas_context.drawImage(ie2, ((this.step % (ie2.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
            }
          } else {

            if (this.team.top == 1) {
              canvas_context.drawImage(ie3, ((this.step % (ie3.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
            } else {
              canvas_context.drawImage(ie4, ((this.step % (ie4.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
            }
          }
        }

        if (this.type == 0) {
          if (this.sleep == 1) {
            canvas_context.drawImage(i1, (20 * 64) + ((this.step % 4) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
          } else {
            canvas_context.drawImage(i1, ((this.step % 20) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
          }
        }
        if (this.type == 1) {
          canvas_context.drawImage(i2, ((this.step % (i2.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 2) {
          canvas_context.drawImage(i3, ((this.step % (i3.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 3) {
          canvas_context.drawImage(i4, ((this.step % (i4.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 4) {
          canvas_context.drawImage(i5, ((this.step % (i5.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 5) {
          canvas_context.drawImage(i6, ((this.step % (i6.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 6) {
          canvas_context.drawImage(i7, ((this.step % (i7.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 7) {
          canvas_context.drawImage(i8, ((this.step % (i8.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 8) {
          canvas_context.drawImage(i9, ((this.step % (i9.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 9) {
          canvas_context.drawImage(i10, ((this.step % (i10.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }
        if (this.type == 10) {
          canvas_context.drawImage(i11, ((this.step % (i11.width / 64)) * 64), 0, 64, 64, this.body.x - this.body.radius, this.body.y - this.body.radius, 2 * this.body.radius, 2 * this.body.radius)
        }

      }


      power4(type) {
        if (type == -1) {
          return this.unitmelee
        }
        if (type == 0) {
          return this.shielding
        }
        if (type == 1) {
          return this.sliming
        }
        if (type == 2) {
          return this.shockwaveP
        }
        if (type == 3) {
          return this.boombeam
        }
        if (type == 4) {
          return this.manazone
        }
        if (type == 5) {
          return this.solarflares
        }
        if (type == 6) {
          return this.bananafield
        }
        if (type == 7) {
          return this.warp
        }
        if (type == 8) {
          return this.healthrushing
        }
        if (type == 9) {
          return this.healblastred
        }
        if (type == 10) {
          return this.champBasicAbility
        }
      }
      power3(type) {
        if (type == -1) {
          return this.unitmelee
        }
        if (type == 0) {
          return this.sleeping
        }
        if (type == 1) {
          return this.slugrushing
        }
        if (type == 2) {
          return this.rushing
        }
        if (type == 3) {
          return this.blastjump
        }
        if (type == 4) {
          return this.nhaiSpike
        }
        if (type == 5) {
          return this.psychosolar
        }
        if (type == 6) {
          return this.rushing
        }
        if (type == 7) {
          return this.selfheal
        }
        if (type == 8) {
          return this.butterstar
        }
        if (type == 9) {
          return this.psychosolar
        }
        if (type == 10) {
          return this.blastjump2
        }
      }

      power2(type) {
        if (type == -1) {
          return this.unitmelee
        }
        if (type == 0) {
          return this.shockwave
        }
        if (type == 1) {
          return this.yspike
        }
        if (type == 2) {
          return this.tonguegrab
        }
        if (type == 3) {
          return this.bombfield
        }
        if (type == 4) {
          return this.nhaiShotToggle
        }
        if (type == 5) {
          return this.fusion
        }
        if (type == 6) {
          return this.bananarang
        }
        if (type == 7) {
          return this.deathx
        }
        if (type == 8) {
          return this.wingclip
        }
        if (type == 9) {
          return this.bananarangred
        }
        if (type == 10) {
          return this.jetzone
        }

      }
      power1(type) {
        if (type == -1) {
          return this.unitmelee
        }
        if (type == 0) {
          return this.psyblast
        }
        if (type == 1) {
          return this.slugmax
        }
        if (type == 2) {
          return this.eggspit
        }
        if (type == 3) {
          return this.bigbomb
        }
        if (type == 4) {
          return this.healblast
        }
        if (type == 5) {
          return this.burnout
        }
        if (type == 6) {
          return this.bananaboundary
        }
        if (type == 7) {
          return this.ringkill
        }
        if (type == 8) {
          return this.spawnminion
        }
        if (type == 9) {
          return this.hamblast
        }
        if (type == 10) {
          return this.jetrushing
        }
      }

      spawnminion(self, x, y) {


        let manaCost = 35
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }


        let guy2z = new Champ(-1, teams[0])
        guy2z.body.x = x
        guy2z.body.y = y
        guy2z.skin = 2
        guy2z.send = 1
        guy2z.tar = 4
        guy2z.zop = 1
        players.push(guy2z)
        champids.push(guy2z.id)
        champtimes.push(2000000000)
        self.cooldowns[0] = 180


        let shocher = new Circle(self.body.x, self.body.y, 1, "transparent")
        shocher.life = 3
        shocher.song = "shoot.wav"
        self.activeArts.push(shocher)

      }
      unitmeleeChamp(self, target) {
        let l = new LineOP(self.body, target.body)
        if (l.hypotenuse() < (self.meleeRange * 1.15)) {
          if (target.shield == 1) {
          } else {
            // target.health -= 34
            if (target.health <= 0) {

              self.gold += target.reward(self)
              self.goldtotal += target.reward(self)
            }
          }
          self.cooldowns[4] = 30 * 1
          let manaCost = 0
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 6
          let d = new MeleeSpike(players.indexOf(self), self.meleeRange, (new LineOP(self.body, new Point(target.body.x, target.body.y)).angle()), "gray")
          d.echo = 1
          d.life = lifeLength
          d.line = 1
          d.growth = 1
          d.growth = 1.3
          d.root = self.body
          d.maxDis = self.meleeRange
          d.damage = 60
          // d.collide = 1
          d.emptyOut = 1
          d.update = 1
          d.name = "MeleeSpike"
          self.activeArts.push(d)
        }
      }
      unitmelee(self, target) {
        let l = new LineOP(self.body, target.body)
        if (l.hypotenuse() < 70) {
          if (target.shield == 1) {

          } else {
            // target.health -= 10
            if (target.health <= 0) {
              self.gold += target.reward(self)
              self.goldtotal += target.reward(self)
            }
          }
          self.cooldowns[0] = 30 * 1
          let manaCost = 0
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 6
          let d = new MeleeSpike(players.indexOf(self), 64, (new LineOP(self.body, new Point(target.body.x, target.body.y)).angle()), "gray")
          d.echo = 1
          d.life = lifeLength
          d.line = 1
          d.growth = 1
          d.growth = 1.3
          d.root = self.body
          d.maxDis = 70
          d.damage = 10
          // d.collide = 1
          d.emptyOut = 1
          d.update = 1
          d.name = "MeleeSpike"
          self.activeArts.push(d)
        }
      }
      warp(self, x, y) {
        let manaCost = 25
        let healthcost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        if (self.health < healthcost) {
          self.mana += manaCost
          return
        } else {
          self.health -= healthcost
        }
        self.body.x = x
        self.body.y = y
        self.goal.x = x
        self.goal.y = y

        canvas_context.resetTransform()
        canvas_context.translate(-(players[0].body.x - 640), -(players[0].body.y - 360));
        translator.x = -(players[0].body.x - 640)
        translator.y = -(players[0].body.y - 360)

        let shocher = new Circle(self.body.x, self.body.y, 1, "transparent")
        shocher.life = 3
        shocher.song = "rush.mp3"
        self.activeArts.push(shocher)

        self.cooldowns[3] = 60
      }

      nhaigrape(self, x, y) {


        self.slimeTime++
        if (self.slimeTime % 16 == 0) {
          let l = new LineOP(self.body, new Point(x, y))
          let manaCost = 10
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 22
          let shocher = new Circle(self.body.x, self.body.y, 12, "#8800ff", Math.cos(l.angle()) * 2 * 10, Math.sin(l.angle()) * 2 * 10)
          shocher.growth = .999
          // shocher.root = self.body
          shocher.life = lifeLength
          shocher.slow = .5
          shocher.collide = 1
          shocher.damage = 12
          shocher.update = 1
          shocher.pop = 1
          shocher.song = "slugdrop.wav"
          shocher.popdam = 4
          shocher.poprays = 5
          shocher.poprate = 10
          shocher.popradius = 5
          shocher.popcolor = "purple"
          shocher.poplife = 10
          shocher.name = "Circle"
          self.activeArts.push(shocher)
        }
      }
      nhaiShotToggle(self, x, y) {
        if (self.cooldowns[1] <= 0) {
          self.slimeTime = 0
          self.slimeToggle *= -1
          self.cooldowns[1] = 30
        }
      }
      boombeam(self, x, y) {

        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 200
        let d = new BoomSpike(players.indexOf(self), 30, (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.moveAngle = 1
        d.growth = 1
        d.growth = 1.3
        d.root = self.body
        d.anchorToPlayer = 1
        d.solar = 1
        d.bod = 1
        d.bodi = 1
        d.bodid = self.id

        d.maxDis = 100
        d.damage = 5
        d.update = 1
        d.name = "BoomSpike"
        self.activeArts.push(d)
        self.cooldowns[3] = 40 * 10
      }
      burnout(self, x, y) {
        let manaCost = 50
        let healthcost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        if (self.health < healthcost) {
          self.mana += manaCost
          return
        } else {
          self.health -= healthcost
        }

        let lifeLength = 100
        let shocher = new Circle(self.body.x, self.body.y, 50, "#FF000044")
        shocher.growth = 1.023
        shocher.root = self.body
        shocher.life = lifeLength
        shocher.update = 1
        shocher.damage = .8
        shocher.slow = .95
        shocher.bod = 1
        shocher.bodi = 1
        shocher.guyIndex = players.indexOf(self)
        shocher.guyid = self.id
        shocher.solar = 1
        shocher.bodid = self.id
        self.activeArts.push(shocher)
        self.cooldowns[0] = 90 * 1
      }
      fusion(self) {
        if (self.health > 50) {
          self.health -= 50
          self.mana += 120
          self.cooldowns[1] = 30 * 5
        }
      }
      selfheal(self, x, y) {

        let manaCost = 50
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        self.health += 200
        if (self.health > self.maxhealth) {
          self.health = self.maxhealth
        }

        self.cooldowns[2] = 1 * 300

        let shocher = new Circle(self.body.x, self.body.y, 1, "transparent")
        shocher.life = 3
        shocher.song = "shield.wav"
        self.activeArts.push(shocher)
      }
      psychosolar(self, x, y) {
        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 120
        let d = new PsychoSolar(players.indexOf(self), (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.moveAngle = 1
        d.growth = 1.3
        // d.root = self.body
        d.anchorToPlayer = 1
        d.maxDis = 100
        d.solar = 1
        d.damage = 7 //4
        d.update = 1
        d.name = "PsychoSolar"
        self.activeArts.push(d)
        self.cooldowns[2] = 120 * 4
      }
      butterstar(self, x, y) {
        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 150
        let d = new ButterStar(players.indexOf(self), (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.moveAngle = 1
        d.growth = 1.3
        // d.root = self.body
        d.anchorToPlayer = 1
        d.maxDis = 100
        d.solar = 1
        d.damage = 6
        d.update = 1
        d.name = "ButterStar"
        self.activeArts.push(d)
        self.cooldowns[2] = 120 * 4
      }


      solarflares(self, x, y) {

        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 100
        let d = new SolarFlares(players.indexOf(self), (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.moveAngle = 1
        d.growth = 1
        d.growth = 1.3
        d.root = self.body
        d.guyid = self.id
        // d.anchorToPlayer = 1
        d.maxDis = 100
        d.damage = 3
        d.solar = 1
        d.update = 1
        d.name = "SolarFlares"
        self.activeArts.push(d)
        self.cooldowns[3] = 40 * 10
      }

      bananarang(self, x, y) {

        let l = new LineOP(self.body, new Point(x, y))

        let manaCost = 40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 40
        let shocher = new Circle(self.body.x, self.body.y, 25, "yellow", Math.cos(l.angle()) * -2 * 12, Math.sin(l.angle()) * -2 * 12)
        shocher.growth = 1
        // shocher.root = self.body
        shocher.song = "bananayoyo.mp3"
        shocher.life = lifeLength
        shocher.slow = .5
        shocher.reverse = 1
        shocher.collide = 0
        shocher.damage = 20
        shocher.update = 1
        shocher.pop = 0
        shocher.popdam = 1
        shocher.poprays = 6
        shocher.poprate = 20
        shocher.popradius = 4
        shocher.popcolor = "yellow"
        shocher.poplife = 10
        shocher.name = "Circle"
        self.activeArts.push(shocher)
        self.cooldowns[1] = 60 * 1
      }

      bananarangred(self, x, y) {

        let l = new LineOP(self.body, new Point(x, y))

        let manaCost = 40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 40
        let shocher = new Circle(self.body.x, self.body.y, 25, "red", Math.cos(l.angle()) * -2 * 12, Math.sin(l.angle()) * -2 * 12)
        shocher.growth = 1
        // shocher.root = self.body
        shocher.life = lifeLength
        shocher.slow = .5
        shocher.reverse = 1
        shocher.song = "bananayoyo.mp3"
        shocher.collide = 0
        shocher.damage = 20
        shocher.update = 1
        shocher.pop = 0
        shocher.popdam = 1
        shocher.poprays = 6
        shocher.poprate = 20
        shocher.popradius = 4
        shocher.popcolor = "red"
        shocher.poplife = 10
        shocher.name = "Circle"
        self.activeArts.push(shocher)
        self.cooldowns[1] = 90 * 1
      }
      bananafield(self, x, y) {


        let manaCost = 75
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 200
        let distance = 100
        let angle = (new LineOP(self.body, new Point(x, y)).angle())

        for (let t = 1; t < 24; t++) {
          let d = new Circle(x + (Math.cos(angle) * distance), y + (Math.sin(angle) * distance), 14, "#FFFF0088")
          d.echo = 1
          d.life = lifeLength
          d.growth = 1.001
          if (t == 10) {

            d.song = "bananacurve.mp3"
          }
          // d.root = TIP_engine
          d.maxDis = 3000
          d.update = 1
          d.slow = .5
          d.collide = 0
          d.damage = 2
          d.pop = 0
          // d.sendEveryFrame = 1
          d.popdam = 5
          d.poprays = 9
          d.poprate = 10
          d.popradius = 5
          d.popcolor = "yellow"
          d.poplife = 10
          // distance += 3-(t/30)
          angle += Math.PI / 20
          // if (t % 5 == 0) {
          distance += 4
          // }
          d.name = "Circle"
          self.activeArts.push(d)
        }
        self.cooldowns[3] = 40 * 8
      }

      deathx(self, x, y) {


        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 200
        let distance = 0
        let angle = (new LineOP(self.body, new Point(x, y)).angle())

        for (let t = 1; t < 25; t++) {
          let d = new Circle(x + (Math.cos(angle) * distance), y + (Math.sin(angle) * distance), 18, "#00000088")
          d.echo = 1
          d.life = lifeLength
          d.growth = .99
          // d.root = TIP_engine
          d.maxDis = 3000
          d.update = 1
          d.slow = .5
          d.collide = 0
          d.damage = 1
          d.pop = 0
          // d.sendEveryFrame = 1
          d.popdam = 5
          d.poprays = 9
          d.poprate = 10
          d.popradius = 5
          d.popcolor = "yellow"
          d.poplife = 10
          if (t == 3) {
            d.song = "bananacurve.mp3"
          }
          // distance += 3-(t/30)
          angle += Math.PI / 2
          // if (t % 5 == 0) {
          distance += 4
          // }
          d.name = "Circle"
          self.activeArts.push(d)
        }
        self.cooldowns[1] = 40 * 7
      }

      jetzone(self, x, y) {


        let manaCost = 85
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 100
        let distance = 180
        let angle = (new LineOP(self.body, new Point(x, y)).angle())

        for (let t = 0; t < 40; t++) {
          let d = new Circle(self.body.x + (Math.cos(angle) * distance), self.body.y + (Math.sin(angle) * distance), 24, "#FF000044")
          d.echo = 1
          d.life = lifeLength
          d.growth = 1.002
          // d.root = TIP_engine
          d.maxDis = 3000
          d.update = 1
          d.slow = .1
          d.collide = 1
          d.damage = 10
          d.pop = 1
          if (t == 10) {
            d.song = "bananacurve.mp3"
          }
          // d.sendEveryFrame = 1
          d.popdam = 5
          d.poprays = 4
          d.poprate = 5
          d.popradius = 10
          d.popcolor = "#FF000044"
          d.poplife = 20
          // distance += 3-(t/30)
          angle += (Math.PI / 2) / 10
          if (t < 20) {
            // distance -= 20
          } else {

            // distance += 20
          }
          d.name = "Circle"
          self.activeArts.push(d)
        }
        self.cooldowns[1] = 40 * 3
      }

      wingclip(self, x, y) {


        let manaCost = 75
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 200
        let distance = 200
        let angle = (new LineOP(self.body, new Point(x, y)).angle())

        for (let t = 0; t < 40; t++) {
          let d = new Circle(x + (Math.cos(angle) * distance), y + (Math.sin(angle) * distance), 24, "#00FFFF88")
          d.echo = 1
          d.life = lifeLength
          d.growth = 1.002
          // d.root = TIP_engine
          d.maxDis = 3000
          d.update = 1
          d.slow = .1
          d.collide = 0
          d.damage = .1
          d.pop = 2
          if (t == 2) {
            d.song = "bananacurve.mp3"
          }
          // d.sendEveryFrame = 1
          d.popdam = 0
          d.poprays = 4
          d.poprate = 5
          d.popradius = 10
          d.popcolor = "#0000ff88"
          d.poplife = 20
          // distance += 3-(t/30)
          angle += (Math.PI / 2) / 10
          if (t < 20) {
            // distance -= 20
          } else {

            // distance += 20
          }
          d.name = "Circle"
          self.activeArts.push(d)
        }
        self.cooldowns[1] = 40 * 7
      }

      bombfield(self, x, y) {


        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 200
        let distance = 0
        let angle = (new LineOP(self.body, new Point(x, y)).angle())

        for (let t = 1; t < 20; t++) {
          let d = new Circle(x + (Math.cos(angle) * distance), y + (Math.sin(angle) * distance), 18, "#FFAA0088")
          d.echo = 1
          d.life = lifeLength
          d.growth = .99
          // d.root = TIP_engine
          d.maxDis = 3000
          if (t == 10) {

            d.song = "bananacurve.mp3"
          }
          d.update = 1
          d.slow = .5
          d.collide = 1
          d.damage = 15
          d.pop = 1
          // d.sendEveryFrame = 1
          d.popdam = 5
          d.poprays = 9
          d.poprate = 10
          d.popradius = 5
          d.popcolor = "yellow"
          d.poplife = 10
          // distance += 3-(t/30)
          angle += Math.PI / 2
          if (t % 5 == 0) {
            distance += 40
          }
          d.name = "Circle"
          self.activeArts.push(d)
        }
        self.cooldowns[1] = 40 * 8
      }
      bigbomb(self, x, y) {
        let l = new LineOP(self.body, new Point(x, y))

        let manaCost = 100
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 65
        let shocher = new Circle(self.body.x, self.body.y, 35, "#888888", Math.cos(l.angle()) * 2 * 12, Math.sin(l.angle()) * 2 * 12)
        shocher.growth = .999
        // shocher.root = self.body
        shocher.life = lifeLength
        shocher.slow = .5
        shocher.collide = 1
        shocher.damage = 155
        shocher.update = 1
        shocher.pop = 1
        shocher.song = "shoot.wav"
        shocher.popdam = 15
        shocher.poprays = 9
        shocher.poprate = 10
        shocher.popradius = 5
        shocher.popcolor = "yellow"
        shocher.poplife = 10
        shocher.name = "Circle"
        self.activeArts.push(shocher)
        self.cooldowns[0] = 40 * 4
      }
      ringkill(self, x, y) {
        let l = new LineOP(self.body, new Point(x, y))

        let manaCost = 60
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }

        let lifeLength = 10
        for (let t = 0; t < 9; t++) {
          let ld = t * ((Math.PI * 2) / 9)
          let shocher = new Circle(x + ((Math.cos(ld) * -2 * 16) * 5), y + ((Math.sin(ld) * -2 * 16) * 5), 12, "#222222", Math.cos(ld) * 2 * 16, Math.sin(ld) * 2 * 16)
          shocher.growth = .999
          // shocher.root = self.body
          shocher.life = lifeLength
          shocher.slow = .5
          shocher.collide = 1
          shocher.damage = 15
          shocher.update = 1
          shocher.pop = 0
          shocher.popdam = 10
          shocher.poprays = 17
          shocher.poprate = 10
          shocher.popradius = 5
          shocher.popcolor = "black"
          shocher.poplife = 10
          if (t == 1) {
            shocher.song = "shoot.wav"
          }
          shocher.name = "Circle"
          self.activeArts.push(shocher)
          self.cooldowns[0] = 70 * 2
        }
      }
      eggspit(self, x, y) {
        let l = new LineOP(self.body, new Point(x, y))

        let manaCost = 60
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 65
        let shocher = new Circle(self.body.x, self.body.y, 25, "#ff00ff", Math.cos(l.angle()) * 2 * 16, Math.sin(l.angle()) * 2 * 16)
        shocher.growth = .999
        // shocher.root = self.body
        shocher.life = lifeLength
        shocher.slow = .5
        shocher.collide = 1
        shocher.damage = 125
        shocher.update = 1
        shocher.pop = 1
        shocher.song = "shoot.wav"
        shocher.popdam = 10
        shocher.poprays = 17
        shocher.poprate = 10
        shocher.popradius = 5
        shocher.popcolor = "yellow"
        shocher.poplife = 10
        shocher.name = "Circle"
        self.activeArts.push(shocher)
        self.cooldowns[0] = 40 * 2
      }
      tonguegrab(self, x, y) {
        let manaCost = 70
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 30
        let d = new TongueSpike(players.indexOf(self), 30, (new LineOP(self.body, new Point(x, y)).angle()), "blue", self)
        d.echo = 1
        d.life = lifeLength
        d.growth = 1
        d.growth = 1.15
        d.root = self.body
        d.grab = 1
        d.maxDis = 300
        d.guyid = self.id
        // d.follow = 1
        d.damage = 8
        d.update = 1
        // d.tip = 1
        d.name = "TongueSpike"
        d.song = "shoot.wav"
        self.activeArts.push(d)
        self.cooldowns[1] = 40 * 3
      }
      slugmax(self, x, y) {

        let manaCost = 70
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 100
        let distance = 0
        let angle = (new LineOP(self.body, new Point(x, y)).angle())

        for (let t = 0; t < 60; t++) {
          let d = new Circle(x + (Math.cos(angle) * distance), y + (Math.sin(angle) * distance), 90 - (t / 1), "#AAFF0020")
          d.echo = 1
          d.life = lifeLength
          d.growth = .989
          if (t == 10) {

            d.song = "bananacurve.mp3"
          }
          // d.root = TIP_engine
          d.maxDis = 3000
          d.update = 1
          d.slow = .9
          d.damage = .2
          // d.sendEveryFrame = 1
          distance += 3 - (t / 30)
          angle += (Math.PI + (Math.PI / 60))
          d.name = "Circle"
          self.activeArts.push(d)
        }
        self.cooldowns[0] = 40 * 10
      }
      dropSlime(self) {
        self.slimeTime++
        if (self.slimeTime % 10 == 0) {
          let manaCost = 4
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 70
          let shocher = new Circle(self.body.x, self.body.y, 62, "#00ff0023")
          shocher.growth = .989
          // shocher.root = self.body
          shocher.life = lifeLength
          shocher.poison = 1
          shocher.damage = 1.45
          shocher.song = "slugdrop.wav"
          shocher.slow = .85
          // shocher.sendEveryFrame = 1
          shocher.update = 1
          self.activeArts.push(shocher)
        }
      }
      sliming(self) {

        self.slimeTime = 0
        self.slimeToggle *= -1
        self.cooldowns[3] = 40 * .5
      }


      blastjump2(self) {
        let manaCost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }

        let speedBoost = 4
        self.tempSpeed += speedBoost
        self.boosts.push({ speedDown: 100, dropBy: speedBoost })
        if (self.health <= 0) {
          self.health = 1
        }
        let lifeLength = 20
        let shocher = new Circle(self.body.x, self.body.y, 100, "#FF000044")
        shocher.growth = 1
        // shocher.root = self.body
        shocher.damage = 4
        shocher.life = lifeLength
        shocher.update = 1
        self.activeArts.push(shocher)
        let shocher2 = new Circle(self.body.x, self.body.y, 80, "#FF00ff44")
        shocher2.growth = 1
        // shocher2.root = self.body
        shocher2.damage = 5
        shocher2.life = lifeLength
        shocher2.update = 1
        self.activeArts.push(shocher2)
        self.cooldowns[2] = 40 * 5

        let shoch2er = new Circle(self.body.x, self.body.y, 1, "transparent")
        shoch2er.life = 3
        shoch2er.song = "rush.mp3"
        self.activeArts.push(shoch2er)
      }



      blastjump(self) {
        let manaCost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }

        let speedBoost = 10
        self.tempSpeed += speedBoost
        self.boosts.push({ speedDown: 180, dropBy: speedBoost })
        // self.drops.push({ dirLock: 180 })
        self.health -= self.maxhealth * .1
        if (self.health <= 0) {
          self.health = 1
        }
        let lifeLength = 16
        let shocher = new Circle(self.body.x, self.body.y, 85, "#FFFF0033")
        shocher.growth = 1
        // shocher.root = self.body
        shocher.damage = 4
        shocher.life = lifeLength
        shocher.update = 1
        self.activeArts.push(shocher)
        let shocher2 = new Circle(self.body.x, self.body.y, 80, "#FF000022")
        shocher2.growth = 1
        // shocher2.root = self.body
        shocher2.damage = 4
        shocher2.life = lifeLength
        shocher2.update = 1
        self.activeArts.push(shocher2)
        self.cooldowns[2] = 40 * 5

        let shochesr = new Circle(self.body.x, self.body.y, 1, "transparent")
        shochesr.life = 3
        shochesr.song = "rush.mp3"
        self.activeArts.push(shochesr)
      }

      healthrushing(self) {
        let speedBoost = -2
        self.health += self.maxhealth / 10
        self.mana += self.maxmana / 10
        if (self.health > self.maxhealth) {
          self.health = self.maxhealth
        }
        if (self.mana > self.maxmana) {
          self.mana = self.maxmana
        }
        self.tempSpeed += speedBoost
        self.boosts.push({ speedDown: 180, dropBy: speedBoost })
        self.drops.push({ dirLock: 180 })
        self.cooldowns[3] = 40 * 4
        let shocher = new Circle(self.body.x, self.body.y, 1, "transparent")
        shocher.life = 3
        shocher.song = "rush.mp3"
        self.activeArts.push(shocher)
      }
      jetrushing(self) {

        let manaCost = 25
        let healthcost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        if (self.health < healthcost) {
          self.mana += manaCost
          return
        } else {
          self.health -= healthcost
        }
        let speedBoost = 3
        self.tempSpeed += speedBoost
        self.boosts.push({ speedDown: 60, dropBy: speedBoost })
        self.drops.push({ dirLock: 1 })
        let lifeLength = 16
        let shocher = new Circle(self.body.x, self.body.y, 40, "#FFFF0033")
        shocher.growth = 1
        // shocher.root = self.body
        shocher.damage = 3
        shocher.life = lifeLength
        shocher.update = 1
        self.activeArts.push(shocher)
        let shocher2 = new Circle(self.body.x, self.body.y, 40, "#FF000022")
        shocher2.growth = 1
        // shocher2.root = self.body
        shocher2.damage = 3
        shocher2.life = lifeLength
        shocher2.update = 1
        self.activeArts.push(shocher2)
        self.cooldowns[0] = 30 * 1
        let sdddd = new Circle(self.body.x, self.body.y, 1, "transparent")
        sdddd.life = 3
        sdddd.song = "rush.mp3"
        self.activeArts.push(sdddd)

      }
      rushing(self) {
        let manaCost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }

        let speedBoost = 3
        self.tempSpeed += speedBoost
        self.boosts.push({ speedDown: 180, dropBy: speedBoost })
        self.drops.push({ dirLock: 180 })
        self.cooldowns[2] = 40 * 5

        let shocher = new Circle(self.body.x, self.body.y, 1, "transparent")
        shocher.life = 3
        shocher.song = "rush.mp3"
        self.activeArts.push(shocher)


      }

      slugrushing(self) {
        let manaCost = 25
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }

        let speedBoost = 4
        self.tempSpeed += speedBoost
        self.boosts.push({ speedDown: 180, dropBy: speedBoost })
        self.drops.push({ dirLock: 180 })
        self.cooldowns[2] = 40 * 6
        let shocher = new Circle(self.body.x, self.body.y, 1, "transparent")
        shocher.life = 3
        shocher.song = "rush.mp3"
        self.activeArts.push(shocher)

      }
      sleeping(self) {
        let manaCost = 0
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }

        self.sleep *= -1
        if (self.sleep == 1) {
          self.health += (self.maxhealth / 10)
          if (self.health > self.maxhealth) {
            self.health = self.maxhealth
          }
        } else {
          self.mana += (self.maxmana / 10)
          if (self.mana > self.maxmana) {
            self.mana = self.maxmana
          }
        }
        self.cooldowns[2] = 40 * 2
      }
      shielding(self) {
        if (self.sleep == 1) {
          let manaCost = 100
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 400
          for (let t = 0; t < players.length; t++) {
            if (players[t]) { } else { continue }
            if (players[t].team.top == self.team.top) {
              players[t].shield = 1
              let shocher = new Circle(players[t].body.x, players[t].body.y, 50, "#00FFFF44")
              shocher.growth = 1
              shocher.root = players[t].body
              shocher.life = lifeLength
              shocher.bod = 1
              shocher.bodi = 1
              shocher.bodid = players[t].id
              shocher.guyid = players[t].id
              shocher.solar = 1
              shocher.guyIndex = t
              shocher.update = 1
              shocher.knockShield = 1
              shocher.shield = 1
              shocher.song = "shield.wav"
              players[t].activeArts.push(shocher)
              shocher.damage = 0
            }
          }
          self.cooldowns[3] = 40 * 5
        } else {
          let manaCost = 100
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 300
          for (let t = 0; t < players.length; t++) {
            if (players[t]) { } else { continue }
            if (players[t].team.top == self.team.top) {
              players[t].shield = 1
              let shocher = new Circle(players[t].body.x, players[t].body.y, 50, "#00FFFF44")
              shocher.growth = 1
              shocher.root = players[t].body
              shocher.life = lifeLength
              shocher.update = 1
              shocher.knockShield = 1
              shocher.shield = 1
              shocher.guyid = players[t].id
              shocher.solar = 1
              shocher.guyIndex = t
              shocher.bod = 1
              shocher.bodi = 1
              shocher.song = "shield.wav"
              shocher.bodid = players[t].id
              players[t].activeArts.push(shocher)
              shocher.damage = 0
            }
          }
          self.cooldowns[3] = 40 * 3
        }
      }
      shockwave(self, x, y) {
        if (self.sleep == 1) {
          let manaCost = 60
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 16
          let shocher = new Circle(self.body.x, self.body.y, 85, "#FF000033")
          shocher.growth = 1
          shocher.root = self.body
          shocher.damage = 3
          shocher.life = lifeLength
          shocher.update = 1
          shocher.bod = 1
          shocher.bodi = 1
          shocher.guyIndex = players.indexOf(self)
          shocher.guyid = self.id
          shocher.bodid = self.id
          self.activeArts.push(shocher)
          let shocher2 = new Circle(self.body.x, self.body.y, 80, "#FFffFF22")
          shocher2.growth = 1
          shocher2.root = self.body
          shocher2.damage = 3
          shocher2.life = lifeLength
          shocher2.update = 1
          shocher2.bod = 1
          shocher2.guyIndex = players.indexOf(self)
          shocher2.guyid = self.id
          shocher2.bodi = 1
          shocher2.song = "psyshock.wav"
          shocher2.bodid = self.id
          self.activeArts.push(shocher2)
          self.cooldowns[1] = 40 * 5
        } else {
          let manaCost = 60
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 30
          let shocher = new Circle(self.body.x, self.body.y, 35, "#00ff0033")
          shocher.growth = 1.055
          shocher.root = self.body
          shocher.life = lifeLength
          shocher.update = 1
          shocher.bod = 1
          shocher.bodi = 1
          shocher.guyIndex = players.indexOf(self)
          shocher.guyid = self.id
          shocher.bodid = self.id
          // shocher.anchorToPlayer = 1
          shocher.solar = 1
          shocher.damage = 3.5
          self.activeArts.push(shocher)
          let shocher2 = new Circle(self.body.x, self.body.y, 28, "#FFffFF22")
          shocher2.growth = 1.055
          shocher2.root = self.body
          shocher2.life = lifeLength
          shocher2.damage = 3.5
          shocher2.update = 1
          shocher2.guyIndex = players.indexOf(self)
          shocher2.guyid = self.id
          shocher2.solar = 1
          shocher2.song = "psyshock.wav"
          shocher2.bod = 1
          shocher2.bodi = 1
          shocher2.bodid = self.id
          // shocher2.anchorToPlayer = 1
          self.activeArts.push(shocher2)
          self.cooldowns[1] = 40 * 5
        }
      }
      shockwaveP(self, x, y) {
        let manaCost = 40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 9
        let shocher = new Circle(self.body.x, self.body.y, 35, "#00ffff40")
        shocher.growth = 1.17
        shocher.root = self.body
        shocher.life = lifeLength
        shocher.update = 1
        shocher.damage = 22
        shocher.slow = .05
        shocher.bod = 1
        shocher.guyIndex = players.indexOf(self)
        shocher.guyid = self.id
        shocher.bodi = 1
        // shocher.anchorToPlayer = 1
        shocher.solar = 1
        shocher.song = "psyshock.wav"
        shocher.bodid = self.id
        self.activeArts.push(shocher)
        self.cooldowns[3] = 40 * 3
      }

      manazone(self, x, y) {
        let manaCost = -40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        if (self.mana > self.maxmana) {
          self.mana = self.maxmana
        }
        let lifeLength = 10
        let shocher = new Circle(self.body.x, self.body.y, 35, "#00ffAA40")
        shocher.growth = 1.17
        shocher.root = self.body
        shocher.life = lifeLength
        shocher.update = 1
        shocher.damage = -15
        shocher.healshock = 1
        shocher.slow = .05
        shocher.bod = 1
        shocher.song = "psyshock.wav"
        shocher.bodi = 1
        // shocher.anchorToPlayer = 1
        shocher.guyIndex = players.indexOf(self)
        shocher.guyid = self.id
        shocher.bodid = self.id
        shocher.solar = 1
        self.activeArts.push(shocher)
        self.cooldowns[3] = 500
      }
      healblast(self, x, y) {
        let manaCost = 40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 100
        let d = new Circle(x, y, 10, "#00ff00")
        d.echo = 1
        d.growth = 1
        d.life = lifeLength
        d.bodo = 1
        d.maxDis = 300
        d.tipo = 1
        d.local = 1
        d.root = TIP_engine
        d.follow = 1
        d.song = "psysnap.mp3"
        d.update = 1
        d.damage = -4
        self.activeArts.push(d)
        let dx = new Circle(self.body.x, self.body.y, 10, "#00ff00")
        dx.echo = 1
        dx.life = lifeLength
        dx.update = 1
        dx.root = self.body
        dx.bod = 1
        dx.bodi = 1
        dx.bodid = self.id
        dx.local = 1
        dx.damage = -4
        dx.maxDis = 300
        dx.follow = 1
        // dx.anchorToPlayer = 1
        dx.guyIndex = players.indexOf(self)
        dx.guyid = self.id
        dx.solar = 1
        dx.growth = 1
        self.activeArts.push(dx)
        let dxi = new Circle(self.body.x, self.body.y, 7, "black")
        dxi.echo = 1
        dxi.life = lifeLength
        dxi.update = 1
        dxi.root = self.body
        dxi.local = 1
        dxi.bod = 1
        dxi.bodi = 1
        dxi.bodid = self.id
        dxi.solar = 1
        dxi.guyIndex = players.indexOf(self)
        dxi.guyid = self.id
        // dxi.anchorToPlayer = 1

        dxi.damage = -4
        dxi.growth = 1
        dxi.maxDis = 300
        dxi.follow = 1
        self.activeArts.push(dxi)
        let di = new Circle(x, y, 7, "black")
        di.echo = 1
        di.life = lifeLength
        di.update = 1
        di.root = TIP_engine
        di.tip = 1
        di.local = 1

        di.follow = 1
        di.bodo = 1
        di.maxDis = 300
        di.damage = -4
        di.growth = 1
        self.activeArts.push(di)
        //////////////////////////////console.log(zp)
        if (true) {
          let zp = new LineOP(self.body, d, "#00ff00", 16)
          zp.echo = 1
          zp.growth = 1
          zp.life = lifeLength
          zp.bodo = 1  //hitsbodo
          zp.maxDis = 300
          zp.tipo = 1
          zp.follow = 1
          zp.update = 1
          zp.damage = -4
          self.activeArts.push(zp)
          self.cooldowns[0] = 40 * 10
          //////////////////////////////console.log(zp)
          //////////////////////////////console.log(self.activeArts)
        }

        let zp = new LineOP(self.body, d, "black", 10)
        zp.echo = 1
        zp.growth = 1
        zp.life = lifeLength
        zp.bodo = 1  //hitsbodo
        zp.maxDis = 300
        zp.tipo = 1
        zp.follow = 1
        zp.update = 1
        zp.damage = -4
        self.activeArts.push(zp)
        self.cooldowns[0] = 40 * 10
      }


      healblastred(self, x, y) {
        let manaCost = 40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 100
        let d = new Circle(x, y, 10, "#ff0000")
        d.echo = 1
        d.growth = 1
        d.life = lifeLength
        d.bodo = 1
        d.maxDis = 300
        d.song = "psysnap.mp3"
        d.tipo = 1
        d.local = 1
        d.root = TIP_engine
        d.follow = 1
        d.update = 1
        d.damage = -4
        self.activeArts.push(d)
        let dx = new Circle(self.body.x, self.body.y, 10, "#ff0000")
        dx.echo = 1
        dx.life = lifeLength
        dx.update = 1
        dx.root = self.body
        dx.bod = 1
        dx.bodi = 1
        dx.bodid = self.id
        dx.local = 1
        dx.damage = -4
        dx.maxDis = 300
        dx.follow = 1
        // dx.anchorToPlayer = 1
        dx.guyIndex = players.indexOf(self)
        dx.guyid = self.id
        dx.solar = 1
        dx.growth = 1
        self.activeArts.push(dx)
        let dxi = new Circle(self.body.x, self.body.y, 7, "black")
        dxi.echo = 1
        dxi.life = lifeLength
        dxi.update = 1
        dxi.root = self.body
        dxi.local = 1
        dxi.bod = 1
        dxi.bodi = 1
        dxi.bodid = self.id
        dxi.solar = 1
        dxi.guyIndex = players.indexOf(self)
        dxi.guyid = self.id
        // dxi.anchorToPlayer = 1

        dxi.damage = -4
        dxi.growth = 1
        dxi.maxDis = 300
        dxi.follow = 1
        self.activeArts.push(dxi)
        let di = new Circle(x, y, 7, "black")
        di.echo = 1
        di.life = lifeLength
        di.update = 1
        di.root = TIP_engine
        di.tip = 1
        di.local = 1

        di.follow = 1
        di.bodo = 1
        di.maxDis = 300
        di.damage = -4
        di.growth = 1
        self.activeArts.push(di)
        //////////////////////////////console.log(zp)
        if (true) {
          let zp = new LineOP(self.body, d, "#ff0000", 16)
          zp.echo = 1
          zp.growth = 1
          zp.life = lifeLength
          zp.bodo = 1  //hitsbodo
          zp.maxDis = 300
          zp.tipo = 1
          zp.follow = 1
          zp.update = 1
          zp.damage = -4
          self.activeArts.push(zp)
          //////////////////////////////console.log(zp)
          //////////////////////////////console.log(self.activeArts)
        }

        let zp = new LineOP(self.body, d, "black", 10)
        zp.echo = 1
        zp.growth = 1
        zp.life = lifeLength
        zp.bodo = 1  //hitsbodo
        zp.maxDis = 300
        zp.tipo = 1
        zp.follow = 1
        zp.update = 1
        zp.damage = -4
        self.activeArts.push(zp)
        self.cooldowns[3] = 40 * 7
      }


      bananaboundary(self, x, y) {

        let manaCost = 50
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 200
        let d = new Bananas(players.indexOf(self), (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.growth = 1.03
        d.song = "bananaspin.mp3"
        // d.moveAngle = 1
        d.root = self.body
        d.maxDis = 150
        d.anchorToPlayer = 1
        d.solar = 1
        d.guyIndex = players.indexOf(self)
        d.damage = 7
        d.update = 1
        self.activeArts.push(d)
        self.cooldowns[0] = 40 * 10
      }

      hamblast(self, x, y) {
        let manaCost = 40
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 50
        let d = new Circle(x, y, 10, "Red")
        d.echo = 1
        d.growth = 1
        d.life = lifeLength
        d.bodo = 1
        d.maxDis = 300
        d.song = "psysnap.mp3"
        d.tipo = 1
        d.local = 1
        d.root = TIP_engine
        d.follow = 1
        d.update = 1
        d.damage = 1.2 * 2
        self.activeArts.push(d)
        let dx = new Circle(self.body.x, self.body.y, 10, "Red")
        dx.echo = 1
        dx.life = lifeLength
        dx.update = 1
        dx.root = self.body
        dx.bod = 1
        dx.bodi = 1
        dx.bodid = self.id
        dx.local = 1
        dx.damage = 1.2 * 2
        dx.maxDis = 300
        dx.follow = 1
        // dx.anchorToPlayer = 1
        dx.solar = 1
        dx.guyIndex = players.indexOf(self)
        dx.guyid = self.id
        dx.growth = 1
        self.activeArts.push(dx)
        let dxi = new Circle(self.body.x, self.body.y, 7, "white")
        dxi.echo = 1
        dxi.life = lifeLength
        dxi.update = 1
        dxi.root = self.body
        dxi.local = 1
        dxi.bod = 1
        dxi.bodi = 1
        dxi.bodid = self.id
        dxi.guyIndex = players.indexOf(self)
        dxi.guyid = self.id

        // dxi.anchorToPlayer = 1
        dxi.solar = 1

        dxi.damage = 1.2 * 2
        dxi.growth = 1
        dxi.maxDis = 300
        dxi.follow = 1
        self.activeArts.push(dxi)
        let di = new Circle(x, y, 7, "white")
        di.echo = 1
        di.life = lifeLength
        di.update = 1
        di.root = TIP_engine
        di.tip = 1
        di.local = 1

        di.follow = 1
        di.bodo = 1
        di.maxDis = 300
        di.damage = 1.2 * 2
        di.growth = 1
        self.activeArts.push(di)
        //////////////////////////////console.log(zp)
        if (true) {
          let zp = new LineOP(self.body, d, "Red", 16)
          zp.echo = 1
          zp.growth = 1
          zp.life = lifeLength
          zp.bodo = 1  //hitsbodo
          zp.maxDis = 300
          zp.tipo = 1
          zp.follow = 1
          zp.update = 1
          zp.damage = 1.2 * 2
          self.activeArts.push(zp)
          self.cooldowns[0] = 40 * 10
          //////////////////////////////console.log(zp)
          //////////////////////////////console.log(self.activeArts)
        }

        let zp = new LineOP(self.body, d, "white", 10)
        zp.echo = 1
        zp.growth = 1
        zp.life = lifeLength
        zp.bodo = 1  //hitsbodo
        zp.maxDis = 300
        zp.tipo = 1
        zp.follow = 1
        zp.update = 1
        zp.damage = 1.2 * 2
        self.activeArts.push(zp)
        self.cooldowns[0] = 40 * 2
      }


      psyblast(self, x, y) {
        if (self.sleep == 1) {
          let manaCost = 130
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 60
          let dx = new Circle(self.body.x, self.body.y, 150, "#FF00FF88")
          dx.life = lifeLength
          dx.update = 1
          dx.growth = 1
          dx.damage = 20
          dx.bod = 1
          dx.bodi = 1
          dx.bodid = self.id
          dx.song = "psysnap.mp3"
          // dx.anchorToPlayer = 1
          dx.solar = 1
          dx.guyIndex = players.indexOf(self)
          dx.guyid = self.id
          dx.root = self.body
          self.activeArts.push(dx)
          self.cooldowns[0] = 40 * 10
        } else {
          let manaCost = 130
          if (self.mana < manaCost) {
            return
          } else {
            self.mana -= manaCost
          }
          let lifeLength = 100
          let d = new Circle(x, y, 10, "magenta")
          d.echo = 1
          d.song = "psysnap.mp3"
          d.growth = 1
          d.life = lifeLength
          d.bodo = 1
          d.maxDis = 300
          d.tipo = 1
          d.local = 1
          d.root = TIP_engine
          d.follow = 1
          d.update = 1
          d.damage = 2
          self.activeArts.push(d)
          let dx = new Circle(self.body.x, self.body.y, 10, "magenta")
          dx.echo = 1
          dx.life = lifeLength
          dx.update = 1
          dx.root = self.body
          dx.bod = 1
          dx.bodi = 1
          dx.bodid = self.id
          dx.local = 1
          dx.damage = 2
          dx.maxDis = 300
          dx.follow = 1
          // dx.anchorToPlayer = 1
          dx.solar = 1
          dx.guyIndex = players.indexOf(self)
          dx.guyid = self.id
          dx.growth = 1
          self.activeArts.push(dx)
          let dxi = new Circle(self.body.x, self.body.y, 7, "white")
          dxi.echo = 1
          dxi.life = lifeLength
          dxi.update = 1
          dxi.root = self.body
          dxi.local = 1
          dxi.bod = 1
          dxi.bodi = 1
          dxi.bodid = self.id
          dxi.guyIndex = players.indexOf(self)
          dxi.guyid = self.id

          // dxi.anchorToPlayer = 1
          dxi.solar = 1

          dxi.damage = 2
          dxi.growth = 1
          dxi.maxDis = 300
          dxi.follow = 1
          self.activeArts.push(dxi)
          let di = new Circle(x, y, 7, "white")
          di.echo = 1
          di.life = lifeLength
          di.update = 1
          di.root = TIP_engine
          di.tip = 1
          di.local = 1

          di.follow = 1
          di.bodo = 1
          di.maxDis = 300
          di.damage = 2
          di.growth = 1
          self.activeArts.push(di)
          //////////////////////////////console.log(zp)
          if (true) {
            let zp = new LineOP(self.body, d, "magenta", 16)
            zp.echo = 1
            zp.growth = 1
            zp.life = lifeLength
            zp.bodo = 1  //hitsbodo
            zp.maxDis = 300
            zp.tipo = 1
            zp.follow = 1
            zp.update = 1
            zp.damage = 2
            self.activeArts.push(zp)
            self.cooldowns[0] = 40 * 10
            //////////////////////////////console.log(zp)
            //////////////////////////////console.log(self.activeArts)
          }

          let zp = new LineOP(self.body, d, "white", 10)
          zp.echo = 1
          zp.growth = 1
          zp.life = lifeLength
          zp.bodo = 1  //hitsbodo
          zp.maxDis = 300
          zp.tipo = 1
          zp.follow = 1
          zp.update = 1
          zp.damage = 2
          self.activeArts.push(zp)
          self.cooldowns[0] = 40 * 10
        }
      }
      nhaiSpike(self, x, y) {

        let manaCost = 45
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 190
        let d = new NhaiSpike(players.indexOf(self), (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.growth = 1.05
        d.moveAngle = 1
        d.root = self.body
        d.maxDis = 150
        d.anchorToPlayer = 1
        d.solar = 1
        d.guyIndex = players.indexOf(self)
        d.damage = 7
        d.update = 1
        self.activeArts.push(d)
        self.cooldowns[2] = 40 * 10
      }

      yspike(self, x, y) {

        let manaCost = 45
        if (self.mana < manaCost) {
          return
        } else {
          self.mana -= manaCost
        }
        let lifeLength = 90
        let d = new YSpike(players.indexOf(self), (new LineOP(self.body, new Point(x, y)).angle()))
        d.echo = 1
        d.life = lifeLength
        d.line = 1
        d.growth = 1
        d.growth = 1.25
        d.root = self.body
        d.maxDis = 150
        d.damage = 5
        d.update = 1
        self.activeArts.push(d)
        self.cooldowns[1] = 40 * 10
      }

    }



    let psycons = new Image()
    psycons.src = "https://ditzbitz.com/psycons.png"

    let slugcons = new Image()
    slugcons.src = "https://ditzbitz.com/slugcons.png"

    let pomcons = new Image()
    pomcons.src = "https://ditzbitz.com/pomcons.png"

    let miscons = new Image()
    miscons.src = "https://ditzbitz.com/miscons.png"
    let nhaicons = new Image()
    nhaicons.src = "https://ditzbitz.com/nhaicons.png"
    let suncons = new Image()
    suncons.src = "https://ditzbitz.com/suncons.png"

    let banicons = new Image()
    banicons.src = "https://ditzbitz.com/banicons.png"

    let xlicons = new Image()
    xlicons.src = "https://ditzbitz.com/xlicons.png"
    let mantcons = new Image()
    mantcons.src = "https://ditzbitz.com/mantcons.png"
    let jetcons = new Image()
    jetcons.src = "https://ditzbitz.com/jetcons.png"
    let hamcons = new Image()
    hamcons.src = "https://ditzbitz.com/hamcons.png"



    let i1 = new Image()
    i1.src = "https://ditzbitz.com/r2.png"
    let i2 = new Image()
    i2.src = "https://ditzbitz.com/r23.png"
    let i3 = new Image()
    i3.src = "https://ditzbitz.com/r12.png"
    let i4 = new Image()
    i4.src = "https://ditzbitz.com/r27.png"
    let i5 = new Image()
    i5.src = "https://ditzbitz.com/r26.png"
    let i6 = new Image()
    i6.src = "https://ditzbitz.com/r14.png"
    let i7 = new Image()
    i7.src = "https://ditzbitz.com/r17.png"
    let i8 = new Image()
    i8.src = "https://ditzbitz.com/r39.png"
    let i9 = new Image()
    i9.src = "https://ditzbitz.com/r37.png"
    let i10 = new Image()
    i10.src = "https://ditzbitz.com/r82.png"
    let i11 = new Image()
    i11.src = "https://ditzbitz.com/r76.png"
    let ie1 = new Image()
    ie1.src = "https://ditzbitz.com/c51.png"
    let ie2 = new Image()
    ie2.src = "https://ditzbitz.com/c51b.png"
    let ie4 = new Image()
    ie4.src = "https://ditzbitz.com/c2.png"
    let ie3 = new Image()
    ie3.src = "https://ditzbitz.com/c2b.png"
    let characters = []
    function genericReward() {
      return 50
    }

    let teamMaker = -1
    let teamMakerz = -1

    let wodmap = new Image()
    wodmap.src = "https://ditzbitz.com/wodmap3.png"
    let wodmapz = new Image()
    wodmapz.src = "https://ditzbitz.com/wodmapz.png"
    let time = -1


    let ws



    let chatsetup = 0
    let HOST = location.origin.replace(/^http/, 'ws')

    // Check if the page is served over HTTP or HTTPS
    if (location.protocol === 'http:' || location.protocol === 'https:') {
      // If served over HTTP or HTTPS, replace the protocol with 'ws'
      HOST = location.origin.replace(/^http/, 'ws');
    } else {
      // If served over any other protocol (e.g., 'file'), use a default WebSocket URL
      HOST = 'ws://example.com'; // Replace 'example.com' with your WebSocket server URL
    }


    ws = new WebSocket(HOST);
    let enterlock = 0
    let typing = 0


    // window.addEventListener('DOMContentLoaded', (event) => {
    socketize(ws)
    function socketize(ws) {

      // ws.addEventListener("open", () => {
      ws.addEventListener("message", ({ data }) => {
        logBinarySize(data)
        if (JSON.parse(data).roomData == 1) {
          localRooms = [...JSON.parse(data).roomNums]
          // localRooms[localRoom] -= 1
        } else {
          if (teammaker == -1) {
            return
          }
        }
        if (JSON.parse(data).roomData == 1 || JSON.parse(data).roomQuery == 1) {

        } else {
          if (JSON.parse(data).autobalance >= 0) {
            autobalance = 1
            console.log("hit")
            return
          }
          matchStart = 1
        }



        //////////////////////////////////////////////////////////console.log(data)
        // if (!(JSON.parse(data).flies > 0)) {
        //////////////////////////////////////////////////////////console.log("hit")
       if (JSON.parse(data).message >= 0) {

        chat.chats.push(JSON.parse(data).text)
        chat.alpha = 1
        chat.ypointer += 19
        // chat.c.translate(0, 9)



        }else  if (JSON.parse(data).spliceflag >= 0) {

          let guy = players[champids.indexOf(JSON.parse(data).playerid)]

          if (guy) {

            let m = new Point(JSON.parse(data).x, JSON.parse(data).y)
            let list = []
            for (let s = 0; s < guy.activeArts.length; s++) {
              if (guy.activeArts[s]) { } else { continue }
              list.push(guy.activeArts[s].id)
            }

            let z = guy.activeArts[list.indexOf(JSON.parse(data).objectid)]

            if (z) {
              if (z.pop == 1) {
                let angle = 0
                for (let p = 0; p < z.poprays; p++) {
                  let ojb = new Circle(m.x, m.y, z.popradius, z.popcolor, Math.cos(angle) * z.poprate, Math.sin(angle) * z.poprate)
                  ojb.life = z.poplife
                  ojb.damage = z.popdam
                  ojb.collide = 1
                  ojb.id = z.id + 1 + p

                  angle += (Math.PI * 2) / z.poprays
                  ojb.name = "Circle"
                  guy.activeArts.push(ojb)
                }
              }
              guy.activeArts.splice(list.indexOf(JSON.parse(data).objectid), 1)
            }
          }







        } else if (JSON.parse(data).smackupbase >= 0) {

          let top = JSON.parse(data).affiliation
          teams[0].health -= 10
          if (teams[0].health <= 0) {
            worldstop = 1
            if (teams[0].top != top) {
              youLost = 1

            }
          }

        } else if (JSON.parse(data).rewardid >= 0) {
          ////////////////console.log(pop)
          let guy = players[champids.indexOf(JSON.parse(data).rewardid)]
          if (!guy) {
            if (champids.includes(JSON.parse(data).splicid)) {
              let d = champids.indexOf(JSON.parse(data).splicid)
              players.splice(d, 1)
              champids.splice(d, 1)
              champtimes.splice(d, 1)
            }
            return
          }
          if (guy.type != -1) {
            let pop = new DeathPop(JSON.parse(data).x, JSON.parse(data).y, parseInt(JSON.parse(data).reward, 10))
            worldpops.push(pop)
          } else {

            let pop = new DeathPop(JSON.parse(data).x, JSON.parse(data).y, "")
            worldpops.push(pop)
          }
          guy.gold += parseInt(JSON.parse(data).reward, 10)
          guy.goldtotal += parseInt(JSON.parse(data).reward, 10)

          if (champids.includes(JSON.parse(data).splicid)) {
            let d = champids.indexOf(JSON.parse(data).splicid)
            players.splice(d, 1)
            champids.splice(d, 1)
            champtimes.splice(d, 1)
          }

        } else if (JSON.parse(data).collider == 1) {
          ////////console.log(data)
          //////////////////////////////////////////console.log(JSON.parse(data))
          if (champids.indexOf(JSON.parse(data).champid) > -1) {
            let wet = 0
            if (champids.includes(JSON.parse(data).champid)) {
              wet = 1
            }

            if (wet == 1) {
              let k = Object.keys(JSON.parse(JSON.parse(data).packet))
              // //////////////////////////////////////////////////////console.log((JSON.parse(data)).isA)
              let guy = players[champids.indexOf(JSON.parse(data).champid)]
              ////////console.log(champids.indexOf(JSON.parse(data).champid))
              if (!guy) {
                return
              }
              let box = eval(`new ${(JSON.parse(data)).isA}()`)
              // if (guy.activeArts.includes(JSON.parse(data).artid)) {  ///lol what?
              //   box = guy.activeArts[guy.activeArts.indexOf(JSON.parse(data).artid)]
              // }

              //////////////////////////////console.log(box) 
              for (let t = 0; t < k.length; t++) {
                if (k[t] == "root") {

                } else if (k[t] == "track") {

                } else {

                  box[k[t]] = JSON.parse(JSON.parse(data).packet)[k[t]]
                }
              }
              //////////////////////console.log(box.life)
              box.local = -1
              ////////////////////////////////////////////////console.log(box)
              box.id = JSON.parse(data).aid

              guy = players[champids.indexOf(JSON.parse(data).champid)]
              ////////console.log(champids.indexOf(JSON.parse(data).champid))
              if (!guy) {
                return
              }
              //////////////////////////////////////////console.log(guy, champids, JSON.parse(data).champid, champids.indexOf(JSON.parse(data).champid), players, box)

              ////////////////////////////////////////////////console.log(JSON.parse(JSON.parse(data).packet).rootflag)
              if (JSON.parse(JSON.parse(data).packet).rootflag == "self") {
                ////////////////////////////////////////////////console.log("d")
                box.root = guy
                box.root.body = guy.body
              }
              // if (JSON.parse(JSON.parse(data).packet).trackflag == "self") {
              ////////////////////////////////////////////////console.log("d")
              // box.track.body = guy.body
              // }

              let list = []
              for (let s = 0; s < guy.activeArts.length; s++) {
                if (guy.activeArts[s]) { } else { continue }
                list.push(guy.activeArts[s].id)
              }
              if (list.includes(box.id)) {

                box.collide = (JSON.parse(data).collide)
                box.bodi = (JSON.parse(data).bodi)
                box.bod = (JSON.parse(data).bod)
                box.bodz = (JSON.parse(data).bodz)
                box.bodo = (JSON.parse(data).bodo)
                box.name = (JSON.parse(data).name)
                box.bodid = (JSON.parse(data).bodid)
                box.solar = (JSON.parse(data).solar)
                box.song = (JSON.parse(data).song)
                box.tip = (JSON.parse(data).tip)
                ////////////////////////////////console.log(box)
                box.track = guy.body
                box.root = guy.root
                if (box.bodz == 1) {
                  box.track = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                  box.root = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                  ////////////////////////////////////console.log(box)
                }
                if (box.tip == 1) {
                  box.track = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                  box.root = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                  ////////////////////////////////////console.log(box)
                }

                if (box.solar == 1) {
                  box.guyIndex = champids.indexOf(JSON.parse(data).champid)
                  //////console.log(box.guyIndex)
                  box.local = 0
                  box.solar = 1
                }
                if (box.bodi == 1) {
                  let j = -1
                  if (players) {
                    for (let z = 0; z < players.length; z++) {
                      if (players[z].id == box.bodid) {
                        ////////////////////////////////////console.log(z)
                        j = z
                      } else {
                      }
                    }
                    //////////////////////////////////console.log(j)
                    box.track = new Circle(players[j].body.x, players[j].body.y)
                    box.root = new Circle(players[j].body.x, players[j].body.y)
                  }
                }
                if (box.bodo == 1) {
                  ////////////////////////////////console.log(box)
                  if (box.name == "Circle") {
                    box.x = JSON.parse(JSON.parse(data).mouse).x
                    box.y = JSON.parse(JSON.parse(data).mouse).y
                    box.bodo = 1
                  } else if (box.name == "LineOP") {
                    box.bodo = 1

                    box.object.x = JSON.parse(JSON.parse(data).bod).x
                    box.object.y = JSON.parse(JSON.parse(data).bod).y
                    box.object.track = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                    box.object.root = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                    box.target = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)


                    box.target.x = JSON.parse(JSON.parse(data).mouse).x
                    box.target.y = JSON.parse(JSON.parse(data).mouse).y
                    box.target.track = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                    box.target.root = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                  }
                  ////////////////////////////////////console.log(box)
                }
                //////////////////////////////////////////console.log(box)
                guy.shield = box.shield
                // guy.activeArts.push(box)
                guy.activeArts[list.indexOf(box.id)] = box


              } else {
                box.collide = (JSON.parse(data).collide)
                box.bodi = (JSON.parse(data).bodi)
                box.bod = (JSON.parse(data).bod)
                box.bodz = (JSON.parse(data).bodz)
                box.bodo = (JSON.parse(data).bodo)
                box.name = (JSON.parse(data).name)
                box.solar = (JSON.parse(data).solar)
                box.song = (JSON.parse(data).song)
                ////////////////////////////////console.log(box)
                box.bodid = (JSON.parse(data).bodid)
                box.tip = (JSON.parse(data).tip)
                box.track = guy.body
                box.root = guy.root
                if (box.bod == 1) {
                  box.track = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                  box.root = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                  ////////////////////////////////////console.log(box)
                }
                if (box.tip == 1) {
                  box.track = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                  box.root = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                  ////////////////////////////////////console.log(box)
                }
                if (box.solar == 1) {
                  box.guyIndex = champids.indexOf(JSON.parse(data).champid)
                  //////console.log(box.guyIndex)
                  box.local = 0
                  box.solar = 1
                }
                if (box.bodi == 1) {
                  let j = -1
                  for (let z = 0; z < players.length; z++) {
                    if (players[z].id == box.bodid) {
                      ////////////////////////////////////console.log(z)
                      j = z
                    } else {
                    }
                  }
                  //////////////////////////////////console.log(j)
                  box.track = new Circle(players[j].body.x, players[j].body.y)
                  box.root = new Circle(players[j].body.x, players[j].body.y)
                }

                if (box.bod == 1) {
                  box.lock = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                }
                if (box.bodo == 1) {
                  ////////////////////////////////console.log(box)
                  if (box.name == "Circle") {
                    box.x = JSON.parse(JSON.parse(data).mouse).x
                    box.y = JSON.parse(JSON.parse(data).mouse).y
                    box.bodo = 1
                  } else if (box.name == "LineOP") {
                    box.bodo = 1


                    box.object.x = JSON.parse(JSON.parse(data).bod).x
                    box.object.y = JSON.parse(JSON.parse(data).bod).y
                    box.object.track = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                    box.object.root = new Circle(JSON.parse(JSON.parse(data).bod).x, JSON.parse(JSON.parse(data).bod).y)
                    box.target = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)


                    box.target.x = JSON.parse(JSON.parse(data).mouse).x
                    box.target.y = JSON.parse(JSON.parse(data).mouse).y
                    box.target.track = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)
                    box.target.root = new Circle(JSON.parse(JSON.parse(data).mouse).x, JSON.parse(JSON.parse(data).mouse).y)

                  }
                  ////////////////////////////////////console.log(box)
                }
                //////////////////////////////////////////console.log(box)
                guy.shield = box.shield
                guy.activeArts.push(box)
              }
            }
          }
        } else if (champids.includes(JSON.parse(data).id)) {
          // ////////////////////////////////////////////////////////console.log(teams[0], (((JSON.parse(data).team*1)+0)))
          if (JSON.parse(data).minion == 1) {
            ////////////////////////////////////console.log(JSON.parse(data))
            if (champids.indexOf(JSON.parse(data).id) > 0) {
              // //////////////////////////////////////////console.log(JSON.parse(data).id, players, champids)
              let guy = players[champids.indexOf(JSON.parse(data).id)]
              if (guy) {
                if (!guy.activeArts) {
                  // guy.activeArts = []
                }
              } else {
                return
              }
              guy.send = 0
              let junk = [...guy.activeArts]
              // ////////////////////console.log(junk, players[champids.indexOf(JSON.parse(data).id)].activeArts)
              guy.body.x = JSON.parse(data).x
              guy.body.y = JSON.parse(data).y
              guy.shield = JSON.parse(data).shield
              guy.send = 0
              guy.health = Math.min(JSON.parse(data).health, guy.health)
              guy.skin = JSON.parse(data).skin, guy.health
              players[champids.indexOf(JSON.parse(data).id)].activeArts = [...junk]
              champtimes[champids.indexOf(JSON.parse(data).id)] = 20
              // players[0].collide(players[champids.indexOf(JSON.parse(data).id)])
            }
          } else if (JSON.parse(data).champ == 1) {

            // if (champids.length - 1 == 0) {

            // let guy = new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1]) //teams[(((JSON.parse(data).team*1)+0))]
            // guy.health = JSON.parse(JSON.parse(data).packet).health
            // guy.slowedByFloor = JSON.parse(data).slowedByFloor
            // guy.mana = JSON.parse(JSON.parse(data).packet).mana
            // } else if (champids.length  > 0) {
            if (champids.includes(JSON.parse(data).id)) {
              //////////////////console.log("sdn")
              // champids.push(JSON.parse(data).id)
              ////////////////////////////////////////////////////console.log("hit")
              //////////////////////////////////////////////////////////console.log("hit")
              // ////////////////////////////////////////////////////////console.log(teams[0], (JSON.parse(data)))
              ////////////////////////////////////////////////////console.log(teams[0], ((JSON.parse(data).team*1)+0))
              let guy = players[champids.indexOf(JSON.parse(data).id)]    //new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1])
              if (!guy) {
                return
              }
              guy.team = {}
              let junk = [...guy.activeArts]
              guy.send = 0
              guy.team.players = []
              guy.team.top = JSON.parse(data).top
              let k = Object.keys(JSON.parse(JSON.parse(data).packet))
              for (let t = 0; t < k.length; t++) {
                if ([k[t]] == "activeArts") {

                } else if ([k[t]] == "team") {

                } else if ([k[t]] == "body") {

                } else {

                  guy[k[t]] = JSON.parse(JSON.parse(data).packet)[k[t]]
                }
              }
              guy.send = 0
              guy.sleep = JSON.parse(data).sleep
              guy.health = JSON.parse(JSON.parse(data).packet).health
              guy.slowedByFloor = JSON.parse(data).slowedByFloor
              guy.mana = JSON.parse(JSON.parse(data).packet).mana
              // guy.body = new Circle(0, 0, JSON.parse(JSON.parse(data).packet).body.radius)
              guy.body.x = JSON.parse(JSON.parse(data).packet).body.x
              guy.body.y = JSON.parse(JSON.parse(data).packet).body.y
              for (let t = 0; t < JSON.parse(JSON.parse(data).packet).gear.length; t++) {
                guy.gear[t] = new Gear(JSON.parse(JSON.parse(data).packet).gear[t], guy, t)
              }
              guy.abilities = [guy.power1(guy.type), guy.power2(guy.type), guy.power3(guy.type), guy.power4(guy.type)]
              // ////////////////////////////////////////////////////////console.log(guy)
              players[champids.indexOf(JSON.parse(data).id)] = guy
              players[champids.indexOf(JSON.parse(data).id)].activeArts = [...junk]
              champtimes[champids.indexOf(JSON.parse(data).id)] = 20
              // players[0].collide(players[champids.indexOf(JSON.parse(data).id)])
            } else {

              let guy = new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1])//new Champ()    //new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1])
              guy.team = {}
              guy.send = 0
              let junk = [...guy.activeArts]
              ////////////////////console.log(junk)
              guy.team.players = []
              guy.team.top = JSON.parse(data).top
              let k = Object.keys(JSON.parse(JSON.parse(data).packet))
              for (let t = 0; t < k.length; t++) {
                if ([k[t]] == "activeArts") {

                } else if ([k[t]] == "team") {

                } else if ([k[t]] == "body") {

                } else {

                  guy[k[t]] = JSON.parse(JSON.parse(data).packet)[k[t]]
                }
              }
              guy.send = 0
              guy.sleep = JSON.parse(data).sleep
              guy.health = JSON.parse(JSON.parse(data).packet).health
              guy.slowedByFloor = JSON.parse(data).slowedByFloor
              guy.mana = JSON.parse(JSON.parse(data).packet).mana
              // guy.body = new Circle(0, 0, JSON.parse(JSON.parse(data).packet).body.radius)
              guy.body.x = JSON.parse(JSON.parse(data).packet).body.x
              guy.body.y = JSON.parse(JSON.parse(data).packet).body.y
              for (let t = 0; t < JSON.parse(JSON.parse(data).packet).gear.length; t++) {
                guy.gear[t] = new Gear(JSON.parse(JSON.parse(data).packet).gear[t], guy, t)
              }
              guy.abilities = [guy.power1(guy.type), guy.power2(guy.type), guy.power3(guy.type), guy.power4(guy.type)]
              // ////////////////////////////////////////////////////////console.log(guy)
              guy.activeArts = [...junk]
              players.push(guy)
              //////////////////console.log(guy)
              champtimes.push(20)
            }
            // if (champids.indexOf(JSON.parse(data).id) > 0) {



            //   // //////////////////////////////////////////console.log(JSON.parse(data).id, players, champids)
            //   let guy = players[champids.indexOf(JSON.parse(data).id)]
            //   if (guy) {
            //     if (!guy.activeArts) {
            //       // guy.activeArts = []
            //     }
            //   } else {
            //     return
            //   }
            //   let junk = [...guy.activeArts]

            //   ////////////////////console.log(junk)
            //   // ////////////////////////////////////////////////console.log(junk, players[champids.indexOf(JSON.parse(data).id)].activeArts)

            //   //new Champ(JSON.parse(JSON.parse(data).packet).type, teams[0])
            //   let k = Object.keys(JSON.parse(JSON.parse(data).packet))
            //   for (let t = 0; t < k.length; t++) {
            //     if ([k[t]] == "activeArts") {

            //     } else if ([k[t]] == "team") {

            //     } else if ([k[t]] == "body") {

            //     } else {
            //       guy[k[t]] = JSON.parse(JSON.parse(data).packet)[k[t]]
            //     }
            //   }
            //   // guy.body = new Circle(0, 0, JSON.parse(JSON.parse(data).packet).body.radius)
            //   guy.slowedByFloor = JSON.parse(data).slowedByFloor
            //   guy.health = JSON.parse(JSON.parse(data).packet).health
            //   guy.mana = JSON.parse(JSON.parse(data).packet).mana
            //   guy.body.x = JSON.parse(JSON.parse(data).packet).body.x
            //   guy.body.y = JSON.parse(JSON.parse(data).packet).body.y
            //   for (let t = 0; t < JSON.parse(JSON.parse(data).packet).gear.length; t++) {
            //     guy.gear[t] = new Gear(JSON.parse(JSON.parse(data).packet).gear[t], guy, t)
            //   }
            //   guy.abilities = [guy.power1(guy.type), guy.power2(guy.type), guy.power3(guy.type), guy.power4(guy.type)]
            //   //////////////////////////////////////////////////////////console.log("hit")
            //   players[champids.indexOf(JSON.parse(data).id)] = guy
            //   players[champids.indexOf(JSON.parse(data).id)].activeArts = [...junk]
            //   ////////////////////console.log(junk)
            //   // players[0].collide(players[champids.indexOf(JSON.parse(data).id)])
            // }
            // //////////////////////////////////////////////////console.log(junk, players[champids.indexOf(JSON.parse(data).id)].activeArts)

            // for (let t = 0; t < players.length; t++) {
            // if (players[t]) { } else { continue }
            //   for (let k = 0; k < players.length; k++) {
            //     if (t != k) {
            //     }
            //   }
            // }


          }
        } else {

          //////////////////////////////////////////////////////////console.log("hit")
          if (JSON.parse(data).minion == 1) {
            ////////////////////////////////////console.log(JSON.parse(data))

            // if (champids.indexOf(JSON.parse(data).id) > 0) {
            // //////////////////////////////////////////console.log(JSON.parse(data).id, players, champids)
            let guy = new Champ(-1, teams[1])
            guy.team = {}
            guy.team.players = []
            guy.team.top = JSON.parse(data).top
            guy.sleep = JSON.parse(data).sleep
            guy.slowedByFloor = JSON.parse(data).slowedByFloor
            if (guy) {
              if (!guy.activeArts) {
                guy.activeArts = []
              }
            } else {
              return
            }
            // let junk = [...guy.activeArts]
            // ////////////////////////////////////////////////console.log(junk, players[champids.indexOf(JSON.parse(data).id)].activeArts)
            guy.body.x = JSON.parse(data).x
            guy.id = JSON.parse(data).id
            guy.body.y = JSON.parse(data).y
            guy.shield = JSON.parse(data).shield
            guy.send = 0
            guy.health = Math.min(JSON.parse(data).health, guy.health)
            guy.skin = JSON.parse(data).skin, guy.health
            champids.push(JSON.parse(data).id)
            champtimes[champids.length - 1] = 25
            // players[0].collide(players[champids.indexOf(JSON.parse(data).id)])
            players[champids.length - 1] = guy
            // ////////////////////////////////////console.log(guy)
            // ////////////////////////////////////console.log(players[champids.length - 1] )
            // }
          } else if (JSON.parse(data).champ == 1) {
            // if (champids.length - 1 == 0) {

            // let guy = new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1]) //teams[(((JSON.parse(data).team*1)+0))]
            // guy.health = JSON.parse(JSON.parse(data).packet).health
            // guy.slowedByFloor = JSON.parse(data).slowedByFloor
            // guy.mana = JSON.parse(JSON.parse(data).packet).mana
            // } else if (champids.length  > 0) {
            if (champids.includes(JSON.parse(data).id)) {
              //////////////////console.log("sdn")
              // champids.push(JSON.parse(data).id)
              ////////////////////////////////////////////////////console.log("hit")
              //////////////////////////////////////////////////////////console.log("hit")
              // ////////////////////////////////////////////////////////console.log(teams[0], (JSON.parse(data)))
              ////////////////////////////////////////////////////console.log(teams[0], ((JSON.parse(data).team*1)+0))
              let guy = players[champids.indexOf(JSON.parse(data).id)]    //new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1])
              guy.team = {}
              let junk = [...guy.activeArts]
              guy.team.players = []
              guy.team.top = JSON.parse(data).top
              let k = Object.keys(JSON.parse(JSON.parse(data).packet))
              for (let t = 0; t < k.length; t++) {
                if ([k[t]] == "activeArts") {

                } else if ([k[t]] == "team") {

                } else if ([k[t]] == "body") {

                } else {

                  guy[k[t]] = JSON.parse(JSON.parse(data).packet)[k[t]]
                }
              }
              guy.send = 0
              guy.sleep = JSON.parse(data).sleep
              guy.health = JSON.parse(JSON.parse(data).packet).health
              guy.slowedByFloor = JSON.parse(data).slowedByFloor
              guy.mana = JSON.parse(JSON.parse(data).packet).mana
              // guy.body = new Circle(0, 0, JSON.parse(JSON.parse(data).packet).body.radius)
              guy.body.x = JSON.parse(JSON.parse(data).packet).body.x
              guy.body.y = JSON.parse(JSON.parse(data).packet).body.y
              for (let t = 0; t < JSON.parse(JSON.parse(data).packet).gear.length; t++) {
                guy.gear[t] = new Gear(JSON.parse(JSON.parse(data).packet).gear[t], guy, t)
              }
              guy.abilities = [guy.power1(guy.type), guy.power2(guy.type), guy.power3(guy.type), guy.power4(guy.type)]
              // ////////////////////////////////////////////////////////console.log(guy)
              players[champids.indexOf(JSON.parse(data).id)] = guy
              players[champids.indexOf(JSON.parse(data).id)].activeArts = [...junk]
              champtimes[champids.indexOf(JSON.parse(data).id)] = 20
              // players[0].collide(players[champids.indexOf(JSON.parse(data).id)])
            } else {

              let guy = new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1])//new Champ()    //new Champ(JSON.parse(JSON.parse(data).packet).type, teams[1])
              guy.team = {}
              let junk = [...guy.activeArts]
              ////////////////////console.log(junk)
              guy.team.players = []
              guy.team.top = JSON.parse(data).top
              let k = Object.keys(JSON.parse(JSON.parse(data).packet))
              for (let t = 0; t < k.length; t++) {
                if ([k[t]] == "activeArts") {

                } else if ([k[t]] == "team") {

                } else if ([k[t]] == "body") {

                } else {

                  guy[k[t]] = JSON.parse(JSON.parse(data).packet)[k[t]]
                }
              }
              guy.send = 0
              guy.sleep = JSON.parse(data).sleep
              guy.health = JSON.parse(JSON.parse(data).packet).health
              guy.slowedByFloor = JSON.parse(data).slowedByFloor
              guy.mana = JSON.parse(JSON.parse(data).packet).mana
              // guy.body = new Circle(0, 0, JSON.parse(JSON.parse(data).packet).body.radius)
              guy.body.x = JSON.parse(JSON.parse(data).packet).body.x
              guy.body.y = JSON.parse(JSON.parse(data).packet).body.y
              for (let t = 0; t < JSON.parse(JSON.parse(data).packet).gear.length; t++) {
                guy.gear[t] = new Gear(JSON.parse(JSON.parse(data).packet).gear[t], guy, t)
              }
              guy.abilities = [guy.power1(guy.type), guy.power2(guy.type), guy.power3(guy.type), guy.power4(guy.type)]
              // ////////////////////////////////////////////////////////console.log(guy)
              guy.activeArts = [...junk]
              players.push(guy)
              //////////////////console.log(guy)
              champtimes.push(20)
            }
          }
        }
        // }


        // ////////////////////////////////////////////////////////////console.log(players)
        // } else {

        //   textcanvas_context.font = "12px arial"
        //   textcanvas_context.fillStyle = JSON.parse(data).color
        //   if (typeof JSON.parse(data).name != "undefined") {
        //     textcanvas_context.fillText(`(${JSON.parse(data).name}) ` + JSON.parse(data).text, 0, 300 + textscroll)

        //     textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
        //     textscroll += 12
        //   }
        //   // text//canvas_context.translate(0, 12)
        //   // textcanvas.translate(0, 12)
        // }
      })

      setTimeout(() => {
        let json = {}
        json.connecting = 1
        logBinarySize(JSON.stringify(json))
        ws.send(JSON.stringify(json))
      }, 3000)
      // })

    }

    class Enemy {
      constructor(x,y,r,g,b){
        this.x = x
        this.y = y
        this.radius = 10
        this.r = r
        this.g = g
        this.b = b
        this.body= new Circle(this.x, this.y, this.radius, `rgb(${this.r}, ${this.g}, ${this.b})`)
        this.body.friction = 1.0001
        this.body.xmom = Math.random()*1
        this.body.ymom = Math.random()*1
        this.body.reflect = 1
        while(Math.abs(this.body.xmom) + Math.abs(this.body.ymom) < 8){
          this.body.xmom*=1.1
          this.body.ymom*=1.1
        }
      }
      draw(){
        for(let t = 0;t<trilas.complinks.length;t++){
          if(trilas.complinks[t].doesPerimeterTouch(this.body)){
            if(t%3 == 0){
              this.r += 33
              this.b += 33
            }
          }
          if(trilas.complinks[t].doesPerimeterTouch(this.body)){
            if(t%3 == 1){
              this.g += 33
              this.b += 33
            }
          }
          if(trilas.complinks[t].doesPerimeterTouch(this.body)){
            if(t%3 == 2){
              this.r += 33
              this.g += 33
            }
          }
        }
      
        this.body.color =  `rgb(${this.r}, ${this.g}, ${this.b})`

        if(this.r > 255){
          this.r = 255
        }

        if(this.g > 255){
          this.g = 255
        }

        if(this.b > 255){
          this.b = 255
        }


        if(this.r + this.b + this.g > 666){
          this.marked = 1
        }


        // this.body.xmom += ( trilas.body.x -this.body.x)/10000
        // this.body.ymom += ( trilas.body.y -this.body.y)/10000

        this.body.frictiveMove()
        this.body.draw()
      }
    }

    class Trilas {
      constructor(x,y){
        this.body = new Circle(360,360,10,"white")
        this.angle = 0
        this.bodies = []
        
        this.combo = 0
        this.score = 0
        this.combotime = 0
        this.powers = [130,130,130]
          this.time = 0
          this.enemies = []
        for(let t = 0;t<45;t++){
          let dot = new Circle(360+((Math.cos(this.angle)*10)), 360+((Math.sin(this.angle)*10)), (25- (Math.ceil(t/9)*Math.ceil(t/9))*1), "cyan")
          if(t%3 ==0 ){
            dot.color = "magenta"
          }     if(t%3 ==1 ){
            dot.color = "cyan"
          }     if(t%3 ==2 ){
            dot.color = "yellow"
          }
          this.angle += (Math.PI/1.5)
          this.bodies.push(dot)

        }
        this.pops = []
      }
      control(){
        

        if(keysPressed['j']){
          if(this.powers[1]>=8){
          this.powers[1]-=8
          this.powers[0]+=8
          }
          if(this.powers[2]>=8){
          this.powers[2]-=8
          this.powers[0]+=8
          }
        }  if(keysPressed['k']){
          if(this.powers[0]>=8){
          this.powers[0]-=8
          this.powers[1]+=8
          }
          if(this.powers[2]>=8){
          this.powers[2]-=8
          this.powers[1]+=8
          }
        }  if(keysPressed['l']){
          if(this.powers[1]>=8){
          this.powers[1]-=8
          this.powers[2]+=8
          }
          if(this.powers[0]>=8){
          this.powers[0]-=8
          this.powers[2]+=8
          }
        }
        if(!(keysPressed['j'] ||keysPressed['k'] ||keysPressed['l'])){
          if(this.powers[0]<130){
            this.powers[0]++
          }
          if(this.powers[1]<130){
            this.powers[1]++
          }
          if(this.powers[2]<130){
            this.powers[2]++
          }
          
          if(this.powers[0]>130){
            this.powers[0]--
          }
          if(this.powers[1]>130){
            this.powers[1]--
          }
          if(this.powers[2]>130){
            this.powers[2]--
          }
          
          if(this.powers[0]<130){
            this.powers[0]++
          }
          if(this.powers[1]<130){
            this.powers[1]++
          }
          if(this.powers[2]<130){
            this.powers[2]++
          }
          
          if(this.powers[0]>130){
            this.powers[0]--
          }
          if(this.powers[1]>130){
            this.powers[1]--
          }
          if(this.powers[2]>130){
            this.powers[2]--
          }

        }
        
        control(this.body, 9)
        if(this.moint){

          while(this.moint.x > 720){
          this.body.x--
          this.moint.x--
        }
        while(this.coint.x > 720){
          this.body.x--
          this.coint.x--
        }
        while(this.yoint.x > 720){
          this.body.x--
          this.yoint.x--
        }
        while(this.moint.y > 720){
          this.body.y--
          this.moint.y--
        }
        while(this.coint.y > 720){
          this.body.y--
          this.coint.y--
        }
        while(this.yoint.y > 720){
          this.body.y--
          this.yoint.y--
        }

        
        while(this.moint.x < 0){
          this.body.x++
          this.moint.x++
        }
        while(this.coint.x < 0){
          this.body.x++
          this.coint.x++
        }
        while(this.yoint.x < 0){
          this.body.x++
          this.yoint.x++
        }
        while(this.moint.y  < 0){
          this.body.y++
          this.moint.y++
        }
        while(this.coint.y  < 0){
          this.body.y++
          this.coint.y++
        }
        while(this.yoint.y  < 0){
          this.body.y++
          this.yoint.y++
        }
        }

        if(keysPressed['q']){
          this.angle+=.05
        }
        if(keysPressed['e']){
          this.angle-=.05
        }
      }
      deathPop(x,y){
        for(let t= 0 ;t<9;t++){
          let pop = new Circle(x, y, 5, "white", Math.cos(t*(Math.PI/4.5))*10,  Math.sin(t*(Math.PI/4.5))*10)
          pop.life = 10
          this.pops.push(pop )
        }
      }
      draw(){
        this.time++
        // this.powers[0]+=(Math.cos(this.time/10))
        // this.powers[1]+=(Math.cos(this.time/10))
        // this.powers[2]+=(Math.cos(this.time/10))
        if(this.time%25 == 0){
          let x = Math.random()*720
          let y= Math.random()*720
          let link = new LineOP(this.body, new Point(x,y))
          while(link.hypotenuse( ) < 100){
             x = Math.random()*720
           y= Math.random()*720
           link = new LineOP(this.body, new Point(x,y))
          }

          this.enemies.push(new Enemy(x,y,Math.random()*128,Math.random()*128,Math.random()*128))
        }
        for(let t = 0;t<this.pops.length;t++){
          this.pops[t].draw()
          this.pops[t].move()
          this.pops[t].life -=1
        }
        for(let t = 0;t<this.enemies.length;t++){
          this.enemies[t].draw()
        }
        
        for(let t = this.pops.length-1;t>=0;t--){
          if(this.pops[t].life<=1){
            this.pops.splice(t,1)
          }
        }


        for(let t = this.enemies.length-1;t>=0;t--){
          if(this.enemies[t].marked==1){
            this.score+=(this.combo+1)
            this.deathPop(this.enemies[t].body.x, this.enemies[t].body.y)
            this.combo++
            this.combotime = this.time
            this.enemies.splice(t,1)
          }
        }
        if(this.combotime - this.time < -60){
          this.combo = 0
        }
        this.control()
        for(let t = 0;t<42;t+=3){
          this.bodies[0+t].x = this.body.x + ((Math.cos(this.angle)*(10+((t*10)/3))))/2
        this.bodies[0+t].y = this.body.y + ((Math.sin(this.angle)*(10+((t*10)/3))))/2
        this.bodies[1+t].x = this.body.x + ((Math.cos(this.angle+(Math.PI/1.5))*(10+((t*10)/3))))/2
        this.bodies[1+t].y = this.body.y + ((Math.sin(this.angle+(Math.PI/1.5))*(10+((t*10)/3))))/2
        this.bodies[2+t].x = this.body.x + ((Math.cos(this.angle+(Math.PI/1.5)+(Math.PI/1.5))*(10+((t*10)/3))))/2
        this.bodies[2+t].y = this.body.y + ((Math.sin(this.angle+(Math.PI/1.5)+(Math.PI/1.5))*(10+((t*10)/3))))/2
        this.bodies[0+t].draw()
        this.bodies[1+t].draw()
        this.bodies[2+t].draw()
        }
        this.magentaBeam = new LineOP(this.body, this.bodies[0])
        this.mangle = this.magentaBeam.angle()
        this.cyanBeam = new LineOP(this.body, this.bodies[1])
        this.cangle = this.magentaBeam.angle()
        this.yellowBeam = new LineOP(this.body, this.bodies[2])
        this.yangle = this.magentaBeam.angle()

        this.buildBeams()


        this.body.draw()

        canvas_context.fillStyle = "White"
        canvas_context.font = "15px comic sans ms"
        canvas_context.fillText("Score: "+ this.score, 5, 15)
        canvas_context.fillText("Combo: "+ this.combo, 5, 30)
        canvas_context.fillText("Combo Time: " +Math.max((60+( this.combotime-this.time)),0), 5, 45)
        canvas_context.fillText("Time: "+Math.max(7200-this.time,0), 5, 60)
      }
      buildBeams(){
        let moint = new Circle(this.body.x + (Math.cos(this.angle)*this.powers[0]), this.body.y + (Math.sin(this.angle)*this.powers[0]), 10, "Magenta")
        let coint = new Circle(this.body.x + (Math.cos(this.angle+(Math.PI/1.5))*this.powers[1]), this.body.y + (Math.sin(this.angle+(Math.PI/1.5))*this.powers[1]), 10, "Cyan")
        let yoint = new Circle(this.body.x + (Math.cos(this.angle+(Math.PI/1.5)+(Math.PI/1.5))*this.powers[2]), this.body.y + (Math.sin(this.angle+(Math.PI/1.5)+(Math.PI/1.5))*this.powers[2]), 10, "Yellow")
        this.moint = moint
        this.coint = coint
        this.yoint = yoint


        let mointw = new Circle(this.body.x + (Math.cos(this.angle)*this.powers[0]), this.body.y + (Math.sin(this.angle)*this.powers[0]), 6, "white")
        let cointw = new Circle(this.body.x + (Math.cos(this.angle+(Math.PI/1.5))*this.powers[1]), this.body.y + (Math.sin(this.angle+(Math.PI/1.5))*this.powers[1]), 6, "white")
        let yointw = new Circle(this.body.x + (Math.cos(this.angle+(Math.PI/1.5)+(Math.PI/1.5))*this.powers[2]), this.body.y + (Math.sin(this.angle+(Math.PI/1.5)+(Math.PI/1.5))*this.powers[2]), 6, "white")

        

        let mlink = new LineOP(this.body, moint, "magenta", 16)
        let clink = new LineOP(this.body, coint, "cyan", 16)
        let ylink = new LineOP(this.body, yoint, "yellow", 16)

        this.complinks = [mlink,clink,ylink]
        let mlinkcomp1 = new LineOP(new Point(mlink.object.x, mlink.object.y), new Point(mlink.target.x, mlink.target.y), "#004400", 3)
        mlinkcomp1.object.x += Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        mlinkcomp1.object.y += Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        mlinkcomp1.target.x += Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        mlinkcomp1.target.y += Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        
        let mlinkcomp2 = new LineOP(new Point(mlink.object.x, mlink.object.y), new Point(mlink.target.x, mlink.target.y), "#004400", 3)
        mlinkcomp2.object.x -= Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        mlinkcomp2.object.y -= Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        mlinkcomp2.target.x -= Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        mlinkcomp2.target.y -= Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))

        
        let clinkcocp1 = new LineOP(new Point(clink.object.x, clink.object.y), new Point(clink.target.x, clink.target.y), "#004400", 3)
        clinkcocp1.object.x += Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        clinkcocp1.object.y += Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        clinkcocp1.target.x += Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        clinkcocp1.target.y += Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        
        let clinkcocp2 = new LineOP(new Point(clink.object.x, clink.object.y), new Point(clink.target.x, clink.target.y), "#004400", 3)
        clinkcocp2.object.x -= Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        clinkcocp2.object.y -= Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        clinkcocp2.target.x -= Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        clinkcocp2.target.y -= Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))

        let ylinkcoyp1 = new LineOP(new Point(ylink.object.x, ylink.object.y), new Point(ylink.target.x, ylink.target.y), "#004400", 3)
        ylinkcoyp1.object.x += Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        ylinkcoyp1.object.y += Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        ylinkcoyp1.target.x += Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        ylinkcoyp1.target.y += Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        
        let ylinkcoyp2 = new LineOP(new Point(ylink.object.x, ylink.object.y), new Point(ylink.target.x, ylink.target.y), "#004400", 3)
        ylinkcoyp2.object.x -= Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        ylinkcoyp2.object.y -= Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        ylinkcoyp2.target.x -= Math.cos(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))
        ylinkcoyp2.target.y -= Math.sin(this.angle+(Math.PI/2))*(8+(keysPressed['q']||keysPressed['e'] ? 5 : 0))

        this.complinks.push(mlinkcomp1)
        this.complinks.push(clinkcocp1)
        this.complinks.push(ylinkcoyp1)
        this.complinks.push(mlinkcomp2)
        this.complinks.push(clinkcocp2)
        this.complinks.push(ylinkcoyp2)
        this.complinks.push(moint)
        this.complinks.push(coint)
        this.complinks.push(yoint)


        let mlinkw = new LineOP(this.body, moint, "white", 4)
        let clinkw = new LineOP(this.body, coint, "white", 4)
        let ylinkw = new LineOP(this.body,yoint, "white", 4)

        moint.draw()
        coint.draw()
        yoint.draw()
        mlink.draw()
        clink.draw()
        ylink.draw()

        mointw.draw()
        cointw.draw()
        yointw.draw()
        mlinkw.draw()
        clinkw.draw()
        ylinkw.draw()
      }
    }

    let trilas = new Trilas(360,360)
    let aud = new Audio()
    aud.src = "erase.mp3"
    aud.volume = .2
    function main() {
      if(trilas.time > 7200){
        canvas_context.fillStyle = "White"
        canvas_context.font = "40px comic sans ms"
        canvas_context.fillText("Score: "+ trilas.score, 30, 250)
        canvas_context.fillStyle = "orange"
        canvas_context.font = "20px comic sans ms"
        canvas_context.fillText("Click to play again", 30, 400)
        return
      }
        canvas_context.clearRect(0,0,canvas.width, canvas.height)
        trilas.draw()
        aud.play()
    }

    // })




  </script>
</div>



</html>